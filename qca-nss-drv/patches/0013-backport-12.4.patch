--- a/exports/nss_c2c_rx.h
+++ b/exports/nss_c2c_rx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -36,7 +36,7 @@ enum nss_c2c_rx_stats_types {
 						/**< Number of received simple pbufs. */
 	NSS_C2C_RX_STATS_PBUF_SG,		/**< Number of scatter-gather pbufs received. */
 	NSS_C2C_RX_STATS_PBUF_RETURNING,	/**< Number of returning scatter-gather pbufs. */
-	NSS_C2C_RX_STATS_INVAL_DEST,		/**< Number of pbuf enqueue failures because of destination is invalid. */
+	NSS_C2C_RX_STATS_INVAL_DEST,		/**< Number of pbuf enqueue failures because destination is invalid. */
 	NSS_C2C_RX_STATS_MAX,			/**< Maximum message type. */
 };
 
--- a/exports/nss_c2c_tx.h
+++ b/exports/nss_c2c_tx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -72,9 +72,9 @@ enum nss_c2c_tx_test_type {
  */
 enum nss_c2c_tx_stats_types {
 	NSS_C2C_TX_STATS_PBUF_SIMPLE = NSS_STATS_NODE_MAX,
-						/**< Number of received simple pbuf. */
-	NSS_C2C_TX_STATS_PBUF_SG,		/**< Number of scatter-gather pbuf received. */
-	NSS_C2C_TX_STATS_PBUF_RETURNING,	/**< Number of returning scatter-gather pbuf. */
+						/**< Number of received simple pbufs. */
+	NSS_C2C_TX_STATS_PBUF_SG,		/**< Number of scatter-gather pbufs received. */
+	NSS_C2C_TX_STATS_PBUF_RETURNING,	/**< Number of returning scatter-gather pbufs. */
 	NSS_C2C_TX_STATS_MAX,			/**< Maximum message type. */
 };
 
--- a/exports/nss_cmn.h
+++ b/exports/nss_cmn.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -27,7 +27,7 @@
  * @{
  */
 
-/*
+/**
  * Interface Number 1 Valid 7 Core 8 Type 16 Index
  */
 typedef int32_t nss_if_num_t;
--- a/exports/nss_gre.h
+++ b/exports/nss_gre.h
@@ -1,6 +1,9 @@
 /*
  ****************************************************************************
  * Copyright (c) 2017-2019, 2021, The Linux Foundation. All rights reserved.
+ *
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -101,16 +104,16 @@ enum nss_gre_msg_types {
 };
 
 /**
- * GRE Mode Types
+ * GRE mode types.
  */
 enum nss_gre_mode {
-	NSS_GRE_MODE_TUN,	/**< GRE Tunnel interface. */
-	NSS_GRE_MODE_TAP,	/**< GRE Tap interface. */
+	NSS_GRE_MODE_TUN,	/**< GRE tunnel interface. */
+	NSS_GRE_MODE_TAP,	/**< GRE TAP interface. */
 	NSS_GRE_MODE_MAX	/**< Maxmum GRE mode. */
 };
 
 /**
- * GRE IP Types
+ * GRE IP types.
  */
 enum nss_gre_ip_types {
 	NSS_GRE_IP_IPV4,	/**<  Outer Tunnel is IPV4. */
@@ -168,11 +171,11 @@ enum nss_gre_session_types {
  * GRE create message structure.
  */
 struct nss_gre_config_msg {
-	uint32_t src_ip[4];			/**< Source IPv4 or IPv6 Adddress. */
-	uint32_t dest_ip[4];			/**< Destination IPv4 or IPv6 Adddress. */
+	uint32_t src_ip[4];			/**< Source IPv4 or IPv6 address. */
+	uint32_t dest_ip[4];			/**< Destination IPv4 or IPv6 address. */
 	uint32_t flags;				/**< GRE Flags. */
-	uint32_t ikey;				/**< GRE rx KEY.*/
-	uint32_t okey;				/**< GRE tx KEY. */
+	uint32_t ikey;				/**< GRE Rx key.*/
+	uint32_t okey;				/**< GRE Tx key. */
 	uint32_t mode;				/**< GRE TUN or TAP. */
 	uint32_t ip_type;			/**< IPv4 or IPv6 type. */
 	uint32_t next_node_if_num;		/**< To whom to forward packets. */
@@ -185,7 +188,7 @@ struct nss_gre_config_msg {
 };
 
 /**
- * GRE link up message structure
+ * GRE link up message structure.
  */
 struct nss_gre_linkup_msg {
 	int if_number;			/**< Interface number. */
@@ -202,11 +205,11 @@ struct nss_gre_linkdown_msg {
  * GRE deconfig message structure
  */
 struct nss_gre_deconfig_msg {
-	int if_number;			/**< Interface number */
+	int if_number;			/**< Interface number. */
 };
 
 /**
- * GRE session statistics message
+ * GRE session statistics message.
  */
 struct nss_gre_session_stats_msg {
 	struct nss_cmn_node_stats node_stats;		/**< Common node statistics. */
@@ -214,7 +217,7 @@ struct nss_gre_session_stats_msg {
 };
 
 /**
- * GRE base statistics message
+ * GRE base statistics message.
  */
 struct nss_gre_base_stats_msg {
 	uint32_t stats[NSS_GRE_BASE_DEBUG_MAX];		/**< Base debug statistics. */
@@ -241,10 +244,10 @@ struct nss_gre_session_stats_notificatio
 
 /**
  * nss_gre_msg
- *	Message structure to send/receive GRE messages
+ *	Message structure to send/receive GRE messages.
  */
 struct nss_gre_msg {
-	struct nss_cmn_msg cm;					/**< Common message header */
+	struct nss_cmn_msg cm;					/**< Common message header. */
 
 	/**
 	 * Payload of a GRE message.
@@ -304,7 +307,7 @@ extern nss_tx_status_t nss_gre_tx_msg_sy
 
 /**
  * nss_gre_tx_buf
- *	Sends packet to the NSS
+ *	Sends a packet to the NSS.
  *
  * @datatypes
  * nss_ctx_instance \n
@@ -445,7 +448,17 @@ typedef void (*nss_gre_pkt_callback_t)(s
  * @return
  * None.
  */
+#ifdef NSS_DRV_GRE_ENABLE
 extern void nss_gre_register_pkt_callback(nss_gre_pkt_callback_t cb);
+#else
+static inline void nss_gre_register_pkt_callback(nss_gre_pkt_callback_t cb)
+{
+	/*
+	 * Dummy registration function for external modules when GRE
+	 * is disabled
+	 */
+}
+#endif
 
 /**
  * nss_gre_unregister_pkt_callback
@@ -457,7 +470,17 @@ extern void nss_gre_register_pkt_callbac
  * @return
  * None.
  */
+#ifdef NSS_DRV_GRE_ENABLE
 extern void nss_gre_unregister_pkt_callback(void);
+#else
+static inline void nss_gre_unregister_pkt_callback(void)
+{
+	/*
+	 * Dummy registration function for external modules when GRE
+	 * is disabled
+	 */
+}
+#endif
 
 /**
  * nss_gre_stats_unregister_notifier
--- a/exports/nss_gre_redir.h
+++ b/exports/nss_gre_redir.h
@@ -302,7 +302,7 @@ struct nss_gre_redir_stats_sync_msg {
 
 /**
  * nss_gre_redir_tun_stats
- *	GRE redirect statistics to accumulate all the stats values.
+ *	GRE redirect statistics to accumulate all stats values.
  */
 struct nss_gre_redir_tun_stats {
 	uint64_t rx_packets;		/**< Number of packets received. */
--- a/exports/nss_if.h
+++ b/exports/nss_if.h
@@ -321,6 +321,23 @@ extern struct nss_ctx_instance *nss_if_r
 extern nss_tx_status_t nss_if_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num);
 
 /**
+ * nss_if_tx_msg_with_size
+ *	Sends a message to the NSS interface.
+ *
+ * @datatypes
+ * nss_ctx_instance \n
+ * nss_if_msg
+ *
+ * @param[in,out] nss_ctx  Pointer to the NSS context.
+ * @param[in]     nim      Pointer to the NSS interface message.
+ * @param[in]     size     Total message buffer size.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+nss_tx_status_t nss_if_tx_msg_with_size(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim, uint32_t size);
+
+/**
  * nss_if_tx_msg
  *	Sends a message to the NSS interface.
  *
@@ -338,7 +355,7 @@ nss_tx_status_t nss_if_tx_msg(struct nss
 
 /**
  * nss_if_msg_sync
- *	Sends a message to the NSS interface and wait for the response.
+ *	Sends a message to the NSS interface and waits for the response.
  *
  * @datatypes
  * nss_ctx_instance \n
@@ -385,7 +402,7 @@ nss_tx_status_t nss_if_reset_nexthop(str
 
 /**
  * nss_if_change_mtu
- *	Change the MTU of the interface.
+ *	Changes the MTU of the interface.
  *
  * @datatypes
  * nss_ctx_instance
@@ -401,7 +418,7 @@ nss_tx_status_t nss_if_change_mtu(struct
 
 /**
  * nss_if_change_mac_addr
- *	Change the MAC address of the interface.
+ *	Changes the MAC address of the interface.
  *
  * @datatypes
  * nss_ctx_instance
@@ -417,7 +434,7 @@ nss_tx_status_t nss_if_change_mac_addr(s
 
 /**
  * nss_if_vsi_unassign
- *	Detach the VSI ID from the given interface.
+ *	Detaches the VSI ID from the given interface.
  *
  * @datatypes
  * nss_ctx_instance
@@ -433,7 +450,7 @@ nss_tx_status_t nss_if_vsi_unassign(stru
 
 /**
  * nss_if_vsi_assign
- *	Attach the VSI ID to the given interface.
+ *	Attaches the VSI ID to the given interface.
  *
  * @datatypes
  * nss_ctx_instance
--- a/exports/nss_ipv4.h
+++ b/exports/nss_ipv4.h
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -55,16 +58,16 @@ struct nss_ipv4_create {
 				/**< Source interface number (virtual or physical). */
 	int32_t dest_interface_num;
 				/**< Destination interface number (virtual or physical). */
-	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
-	uint32_t flags;		/**< Flags (if any) associated with this rule. */
+	int32_t protocol;	/**< L4 protocol, e.g., TCP or UDP. */
+	uint32_t flags;		/**< Flags associated with this rule. */
 	uint32_t from_mtu;	/**< MTU of the incoming interface. */
 	uint32_t to_mtu;	/**< MTU of the outgoing interface. */
 	uint32_t src_ip;	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
 	uint32_t src_ip_xlate;	/**< Translated source IP address (used with SNAT). */
 	int32_t src_port_xlate;	/**< Translated source L4 port (used with SNAT). */
 	uint32_t dest_ip;	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
 	uint32_t dest_ip_xlate;
 			/**< Translated destination IP address (used with DNAT). */
 	int32_t dest_port_xlate;
@@ -82,7 +85,7 @@ struct nss_ipv4_create {
 	uint32_t flow_end;		/**< TCP window end. */
 	uint32_t flow_max_end;		/**< TCP window maximum end. */
 	uint32_t flow_pppoe_if_exist;
-			/**< Flow direction: PPPoE interface exist flag. */
+			/**< Flow direction: PPPoE interface existence flag. */
 	int32_t flow_pppoe_if_num;
 			/**< Flow direction: PPPoE interface number. */
 	uint16_t ingress_vlan_tag;	/**< Ingress VLAN tag expected for this flow. */
@@ -100,7 +103,7 @@ struct nss_ipv4_create {
 			/**< Return direction: PPPoE interface number. */
 	uint16_t egress_vlan_tag;	/**< Egress VLAN tag expected for this flow. */
 	uint8_t spo_needed;		/**< Indicates whether SPO is required. */
-	uint32_t param_a0;		/**< Custom parameter 0. */
+	struct net_device *top_ndev;	/**< Netdevice associated with the top interface. */
 	uint32_t param_a1;		/**< Custom parameter 1. */
 	uint32_t param_a2;		/**< Custom parameter 2. */
 	uint32_t param_a3;		/**< Custom parameter 3. */
@@ -131,9 +134,9 @@ struct nss_ipv4_create {
 struct nss_ipv4_destroy {
 	int32_t protocol;	/**< L4 protocol ID. */
 	uint32_t src_ip;	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
 	uint32_t dest_ip;	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
 };
 
 /**
@@ -900,6 +903,7 @@ enum nss_ipv4_exception_events {
 	NSS_IPV4_EXCEPTION_EVENT_ICMP_IPV4_GRE_HEADER_INCOMPLETE,
 	NSS_IPV4_EXCEPTION_EVENT_ICMP_IPV4_ESP_HEADER_INCOMPLETE,
 	NSS_IPV4_EXCEPTION_EVENT_EMESH_PRIO_MISMATCH,
+	NSS_IPV4_EXCEPTION_EVENT_MC_UCAST_DMAC,
 	NSS_IPV4_EXCEPTION_EVENT_MAX
 };
 
@@ -956,10 +960,10 @@ struct nss_ipv4_node_sync {
 			/**< Number of multicast connection flushes. */
 
 	uint32_t ipv4_connection_create_invalid_mirror_ifnum;
-			/**< Number of create request failed with an invalid mirror interface number. */
+			/**< Number of failed create requests with an invalid mirror interface number. */
 
 	uint32_t ipv4_connection_create_invalid_mirror_iftype;
-			/**< Number of create request failed with an invalid mirror interface type. */
+			/**< Number of failed create requests with an invalid mirror interface type. */
 
 	uint32_t ipv4_mirror_failures;
 			/**< Mirror packet failed. */
--- a/exports/nss_ipv6.h
+++ b/exports/nss_ipv6.h
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -82,14 +85,14 @@ struct nss_ipv6_create {
 			/**< Source interface number (virtual or physical). */
 	int32_t dest_interface_num;
 			/**< Destination interface number (virtual or physical). */
-	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
-	uint32_t flags;		/**< Flags (if any) associated with this rule. */
+	int32_t protocol;	/**< L4 protocol, e.g., TCP or UDP,. */
+	uint32_t flags;		/**< Flags associated with this rule. */
 	uint32_t from_mtu;	/**< MTU of the incoming interface. */
 	uint32_t to_mtu;	/**< MTU of the outgoing interface. */
 	uint32_t src_ip[4];	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
 	uint32_t dest_ip[4];	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
 	uint8_t src_mac[ETH_ALEN];	/**< Source MAC address. */
 	uint8_t dest_mac[ETH_ALEN];	/**< Destination MAC address. */
 	uint8_t flow_window_scale;	/**< Window scaling factor (TCP). */
@@ -111,7 +114,7 @@ struct nss_ipv6_create {
 	uint32_t return_max_end;
 			/**< Maximum end for the return direction. */
 	uint32_t return_pppoe_if_exist;
-			/**< Return direction: PPPoE interface exist flag. */
+			/**< Return direction: PPPoE interface existence flag. */
 	int32_t return_pppoe_if_num;
 			/**< Return direction: PPPoE interface number. */
 	uint16_t egress_vlan_tag;	/**< Egress VLAN tag expected for this flow. */
@@ -132,6 +135,7 @@ struct nss_ipv6_create {
 					/**< Egress VLAN tag expected for this flow. */
 	uint8_t flow_dscp;		/**< IP DSCP value for flow direction. */
 	uint8_t return_dscp;		/**< IP DSCP value for the return direction. */
+	struct net_device *top_ndev;	/**< Netdevice associated with the top interface. */
 };
 
 /**
@@ -139,11 +143,11 @@ struct nss_ipv6_create {
  *	Information for an IPv6 flow or connection destroy rule.
  */
 struct nss_ipv6_destroy {
-	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
+	int32_t protocol;	/**< L4 protocol, e.g., TCP or UDP. */
 	uint32_t src_ip[4];	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
 	uint32_t dest_ip[4];	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
 };
 
 /**
@@ -430,6 +434,7 @@ enum nss_ipv6_exception_events {
 	NSS_IPV6_EXCEPTION_EVENT_ICMP_IPV6_GRE_HEADER_INCOMPLETE,
 	NSS_IPV6_EXCEPTION_EVENT_ICMP_IPV6_ESP_HEADER_INCOMPLETE,
 	NSS_IPV6_EXCEPTION_EVENT_EMESH_PRIO_MISMATCH,
+	NSS_IPV6_EXCEPTION_EVENT_MC_UCAST_DMAC,
 	NSS_IPV6_EXCEPTION_EVENT_MAX
 };
 
@@ -951,10 +956,10 @@ struct nss_ipv6_node_sync {
 			/**< Number of multicast connection flushes. */
 
 	uint32_t ipv6_connection_create_invalid_mirror_ifnum;
-			/**< Number of create request failed with an invalid mirror interface number. */
+			/**< Number of failed create requests with an invalid mirror interface number. */
 
 	uint32_t ipv6_connection_create_invalid_mirror_iftype;
-			/**< Number of create request failed with an invalid mirror interface type. */
+			/**< Number of failed create requests with an invalid mirror interface type. */
 
 	uint32_t ipv6_mirror_failures;
 			/**< Mirror packet failed. */
--- a/exports/nss_lso_rx.h
+++ b/exports/nss_lso_rx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -17,7 +17,7 @@
  */
 
 /*
- * nss_lso_rx.h
+ * @file nss_lso_rx.h
  *	NSS driver LSO (Large Send Offload) Rx header file.
  */
 
--- a/exports/nss_map_t.h
+++ b/exports/nss_map_t.h
@@ -36,14 +36,18 @@
  */
 #define NSS_MAX_MAP_T_DYNAMIC_INTERFACES 4
 
+/**
+ * MAP-T metadata flag.
+ */
 #define NSS_MAPT_MDATA_FLAG_DF_BIT  (1 << 0)
 
-/*
- * mapt meta data
+/**
+ * nss_map_t_mdata
+ *         MAP-T metadata
  */
 struct nss_map_t_mdata {
-	uint16_t flags;
-	uint16_t res[6];
+	uint16_t flags;				/**< Metadata flags. */
+	uint16_t res[6];			/**< Reserved for future use. */
 };
 
 /**
--- a/exports/nss_phy_if.h
+++ b/exports/nss_phy_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, 2021, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -17,7 +17,7 @@
  */
 
 /**
- * @file nss_phy_if.h.h
+ * @file nss_phy_if.h
  *	NSS physical interface definitions.
  */
 
--- a/exports/nss_project.h
+++ b/exports/nss_project.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, 2021 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,6 +38,12 @@
 #define NSS_PROJECT_IRQS_PER_MESSAGE 32
 
 /**
+ *  Maximum possible value of priority after classification
+ *  at an ingress interface.
+ */
+#define NSS_PROJECT_PRI_MQ_MAP_MAX_SIZE 16
+
+/**
  * nss_project_message_types
  *	Project message types.
  */
@@ -46,6 +52,8 @@ enum nss_project_message_types {
 			/**< Message to enable or disable worker thread statistics. */
 	NSS_PROJECT_MSG_WT_STATS_NOTIFY,
 			/**< NSS to HLOS message containing worker thread statistics. */
+	NSS_PROJECT_MSG_SET_QUEUE_PRI_MAP_CFG,
+			/**< Message to configure priority to multi-queue mapping. */
 	NSS_PROJECT_MSG_MAX,
 };
 
@@ -60,6 +68,8 @@ enum nss_project_error_types {
 			/**< The firmware does not support worker thread statistics. */
 	NSS_PROJECT_ERROR_WT_STATS_REDUNDANT_ENABLE,
 			/**< The firmware received a redundant request to enable worker thread statistics. */
+	NSS_PROJECT_ERROR_MQ_NUMBER_INVALID,
+			/**< The firmware received an invalid multi-queue number. */
 	NSS_PROJECT_ERROR_MAX,
 };
 
@@ -111,6 +121,15 @@ struct nss_project_msg_wt_stats_notify {
 };
 
 /**
+ * nss_project_msg_pri_mq_map_cfg
+ * 	NSS priority to multi-queue mapping configuration.
+ */
+struct nss_project_msg_pri_mq_map_cfg {
+	uint8_t pri_mq_map[NSS_PROJECT_PRI_MQ_MAP_MAX_SIZE];
+				/**< Priority to multi-queue mapping array. */
+};
+
+/**
  * nss_project_msg
  *	General message structure for project messages.
  */
@@ -125,6 +144,8 @@ struct nss_project_msg {
 				/**< Enable or disable worker thread statistics. */
 		struct nss_project_msg_wt_stats_notify wt_stats_notify;
 				/**< One-way worker thread statistics message. */
+		struct nss_project_msg_pri_mq_map_cfg pri_mq_map_cfg;
+				/**< Configure priority to multi-queue message. */
 	} msg;			/**< Message payload. */
 };
 
@@ -170,6 +191,17 @@ void nss_project_unregister_sysctl(void)
 void nss_project_register_handler(struct nss_ctx_instance *nss_ctx);
 
 /**
+ * nss_project_pri_mq_map_configure
+ * 	Configures priority to multi-queue mapping.
+ *
+ * @param[in] nss_ctx		Pointer to the NSS context.
+ *
+ * @return
+ * Status of the configuration update operation.
+ */
+extern nss_tx_status_t nss_project_pri_mq_map_configure(struct nss_ctx_instance *nss_ctx);
+
+/**
  * @}
  */
 
--- a/exports/nss_shaper.h
+++ b/exports/nss_shaper.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2017-2018 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2017-2018, 2021 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -59,7 +59,7 @@ enum nss_shaper_config_types {
 	NSS_SHAPER_CONFIG_TYPE_FREE_SHAPER_NODE,
 	NSS_SHAPER_CONFIG_TYPE_SET_DEFAULT,
 	NSS_SHAPER_CONFIG_TYPE_SET_ROOT,
-	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_BASIC_STATS_GET,
+	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_STATS_SYNC_MANY,
 	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_ATTACH,
 	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_DETACH,
 	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_CHANGE_PARAM,
@@ -672,6 +672,7 @@ struct nss_shaper_node_stats {
  *	Statistics response for shaper nodes.
  */
 struct nss_shaper_node_stats_response {
+	uint32_t qos_tag;	/**< QoS tag of the shaper node. */
 	struct nss_shaper_node_stats sn_stats;	/**< Common shaper node statistics. */
 
 	/**
@@ -685,21 +686,27 @@ struct nss_shaper_node_stats_response {
 };
 
 /**
- * nss_shaper_node_stats_get
- *	Statistics of a shaper node.
+ * nss_shaper_node_stats_sync_many
+ * 	Message structure to request shaper node statistics.
  */
-struct nss_shaper_node_stats_get {
+struct nss_shaper_node_stats_sync_many {
 
-	/*
-	 * Request
-	 */
-	uint32_t qos_tag;	/**< QoS tag of the shaper node. */
-
-	/*
-	 * Response
-	 */
-	struct nss_shaper_node_stats_response response;
-				/**< Shaper node statistics response */
+        /*
+         * Request/Response
+         */
+        uint32_t last_qos_tag;                  /**< Last QoS tag. Zero indicates a fresh iteration. */
+
+        /*
+         * Request
+         */
+        uint16_t size;                          /**< Total buffer size indicated by host. */
+
+        /*
+         * Response
+         */
+        uint16_t count;                         /**< Number of shaper nodes for which statistics are copied. */
+        struct nss_shaper_node_stats_response stats_sync[];
+                                                /**< Response to host. */
 };
 
 /**
@@ -726,8 +733,8 @@ struct nss_shaper_configure {
 				/**< Set a shaper to operate in Hybrid mode. */
 		struct nss_shaper_node_config shaper_node_config;
 				/**< Configuration message for any type of shaper node. */
-		struct nss_shaper_node_stats_get shaper_node_stats_get;
-				/**< Statistics for a shaper node. */
+		struct nss_shaper_node_stats_sync_many stats_get;
+				/**< Statistics of multiple shaper nodes. */
 	} msg;			/**< Types of configuration messages. */
 };
 
--- a/exports/nss_virt_if.h
+++ b/exports/nss_virt_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019, 2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -93,8 +93,8 @@ struct nss_virt_if_interface_stats {
  *	Virtual interface statistics received from the NSS.
  */
 struct nss_virt_if_stats {
-	struct nss_virt_if_base_node_stats base_stats;
-	struct nss_virt_if_interface_stats if_stats;
+	struct nss_virt_if_base_node_stats base_stats;	/**< Virtual interface statistics of NSS base node. */
+	struct nss_virt_if_interface_stats if_stats;	/**< Virtual interface statistics of each pair of interfaces. */
 };
 
 /**
--- a/nss_c2c_rx.c
+++ b/nss_c2c_rx.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -107,7 +110,7 @@ void nss_c2c_rx_register_handler(struct
 
 	if (nss_ctx->id == NSS_CORE_0) {
 		nss_c2c_rx_stats_dentry_create();
+		nss_c2c_rx_strings_dentry_create();
 	}
-	nss_c2c_rx_strings_dentry_create();
 }
 EXPORT_SYMBOL(nss_c2c_rx_register_handler);
--- a/nss_c2c_tx.c
+++ b/nss_c2c_tx.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -142,8 +145,8 @@ void nss_c2c_tx_register_handler(struct
 
 	if (nss_ctx->id == NSS_CORE_0) {
 		nss_c2c_tx_stats_dentry_create();
+		nss_c2c_tx_strings_dentry_create();
 	}
-	nss_c2c_tx_strings_dentry_create();
 }
 EXPORT_SYMBOL(nss_c2c_tx_register_handler);
 
--- a/nss_core.c
+++ b/nss_core.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -34,7 +37,13 @@
 #endif
 #include <linux/etherdevice.h>
 #include "nss_tx_rx_common.h"
+
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
+#endif
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+#include "nss_data_plane_lite.h"
+#endif
 
 #define NSS_CORE_JUMBO_LINEAR_BUF_SIZE 128
 
@@ -78,6 +87,10 @@ uint16_t pn_qlimits[NSS_MAX_NUM_PRI] = {
 module_param_array(pn_qlimits, short, NULL, 0);
 MODULE_PARM_DESC(pn_qlimits, "Queue limit per queue");
 
+static int qos_mem_size = 0;
+module_param(qos_mem_size, int, S_IRUGO);
+MODULE_PARM_DESC(qos_mem_size, "QoS memory size");
+
 /*
  * Atomic variables to control jumbo_mru & paged_mode
  */
@@ -85,6 +98,24 @@ static atomic_t jumbo_mru;
 static atomic_t paged_mode;
 
 /*
+ * nss_core_update_qos_mem_size()
+ *	Update the memory size for QoS
+ */
+void nss_core_update_qos_mem_size(int size)
+{
+	qos_mem_size = size;
+}
+
+/*
+ * nss_core_get_qos_mem_size()
+ *	Get the memeory size for QoS
+ */
+int nss_core_get_qos_mem_size(void)
+{
+	return qos_mem_size;
+}
+
+/*
  * nss_core_update_max_ipv4_conn()
  *	Update the maximum number of configured IPv4 connections
  */
@@ -296,6 +327,17 @@ void nss_core_set_subsys_dp_type(struct
 }
 
 /*
+ * nss_core_is_mq_enabled()
+ *	Get multi-queue status.
+ *
+ * Returns 'true' if multi-queue is enabled otherwise returns 'false'.
+ */
+bool nss_core_is_mq_enabled(void)
+{
+	return pn_mq_en;
+}
+
+/*
  * nss_core_register_subsys_dp()
  *	Registers a netdevice and associated information at a given interface.
  *
@@ -489,7 +531,7 @@ static uint32_t nss_soc_mem_info(void)
 	if (ppp) {
 		n_items /= sizeof(ppp[0]);
 		nss_msize = be32_to_cpup(ppp + addr_cells + size_cells - 1);
-		nss_info_always("addr/size storage words %d %d # words %d in DTS, ddr size %x\n",
+		nss_info("addr/size storage words %d %d # words %d in DTS, ddr size %x\n",
 				addr_cells, size_cells, n_items, nss_msize);
 	}
 	of_node_put(snode);
@@ -531,7 +573,7 @@ static void nss_get_ddr_info(struct nss_
 		const __be32 *ppp = (__be32 *)of_get_property(node, "reg", &n_items);
 
 		n_items /= sizeof(ppp[0]);
-		nss_info_always("node size %d # items %d\n",
+		nss_info("node size %d # items %d\n",
 				of_n_size_cells(node), n_items);
 		if (ppp) {
 			if (n_items & 1) {	/* case 1 */
@@ -558,7 +600,7 @@ case3:
 				n_items = 0;
 			if (n_items) {
 				of_node_put(node);
-				nss_info_always("%s: %x %u (avl %u) items %d active_cores %d\n",
+				nss_info("%s: %x %u (avl %u) items %d active_cores %d\n",
 					name, mmu->start_address, mmu->ddr_size,
 					avail_ddr, n_items, mmu->num_active_cores);
 				/*
@@ -895,7 +937,7 @@ static inline void nss_core_handle_buffe
 		/*
 		 * linearize or free if requested.
 		 */
-	 	if (unlikely(skb_is_nonlinear(nbuf))) {
+		if (unlikely(skb_is_nonlinear(nbuf))) {
 			if (nss_core_skb_needs_linearize(nbuf, ndev->features) && __skb_linearize(nbuf)) {
 				dev_kfree_skb_any(nbuf);
 				return;
@@ -953,11 +995,11 @@ static inline void nss_core_handle_ext_b
 	ext_cb = subsys_dp_reg->ext_cb;
 	if (likely(ext_cb) && likely(ndev)) {
 
-	 	if (unlikely(skb_is_nonlinear(nbuf))) {
+		if (unlikely(skb_is_nonlinear(nbuf))) {
 			if (nss_core_skb_needs_linearize(nbuf, ndev->features) && __skb_linearize(nbuf)) {
 				/*
-			 	* We needed to linearize, but __skb_linearize() failed. So free the nbuf.
-			 	*/
+				* We needed to linearize, but __skb_linearize() failed. So free the nbuf.
+				*/
 				dev_kfree_skb_any(nbuf);
 				return;
 			}
@@ -1694,6 +1736,7 @@ static void nss_core_init_nss(struct nss
 {
 	struct nss_top_instance *nss_top;
 	int ret;
+	int i;
 
 	NSS_CORE_DMA_CACHE_MAINT((void *)if_map, sizeof(*if_map), DMA_FROM_DEVICE);
 	NSS_CORE_DSB();
@@ -1709,6 +1752,9 @@ static void nss_core_init_nss(struct nss
 #ifdef NSS_DRV_C2C_ENABLE
 	nss_ctx->c2c_start = nss_ctx->meminfo_ctx.c2c_start_dma;
 #endif
+	for (i = 0; i < NSS_H2N_DESC_RING_NUM; i++) {
+		nss_ctx->h2n_desc_rings[i].nss_index_local = 0;
+	}
 
 	nss_top = nss_ctx->nss_top;
 	spin_lock_bh(&nss_top->lock);
@@ -1718,7 +1764,13 @@ static void nss_core_init_nss(struct nss
 	if (nss_ctx->id) {
 		ret = nss_n2h_update_queue_config_async(nss_ctx, pn_mq_en, pn_qlimits);
 		if (ret != NSS_TX_SUCCESS) {
-			nss_warning("Failed to send pnode queue config to core 1\n");
+			nss_warning("%px: Failed to send pnode queue config to core 1\n", nss_ctx);
+			return;
+		}
+
+		ret = nss_project_pri_mq_map_configure(nss_ctx);
+		if (ret != NSS_TX_SUCCESS) {
+			nss_warning("%px: Failed to send pnode priority to multi-queue config to core 1\n", nss_ctx);
 		}
 		return;
 	}
@@ -1726,16 +1778,22 @@ static void nss_core_init_nss(struct nss
 	/*
 	 * If nss core0 is up, then we are ready to hook to nss-gmac
 	 */
+#if defined(NSS_DATA_PLANE_GENERIC_SUPPORT) || defined(NSS_DATA_PLANE_LITE_SUPPORT)
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	if (nss_data_plane_schedule_registration()) {
-
 		/*
 		 * Configure the maximum number of IPv4/IPv6
 		 * connections supported by the accelerator.
 		 */
+#ifdef NSS_DRV_IPV4_ENABLE
 		nss_ipv4_conn_cfg = max_ipv4_conn;
-		nss_ipv6_conn_cfg = max_ipv6_conn;
 		nss_ipv4_update_conn_count(max_ipv4_conn);
+#endif
+
+#ifdef NSS_DRV_IPV6_ENABLE
+		nss_ipv6_conn_cfg = max_ipv6_conn;
 		nss_ipv6_update_conn_count(max_ipv6_conn);
+#endif
 
 #ifdef NSS_MEM_PROFILE_LOW
 		/*
@@ -1748,11 +1806,25 @@ static void nss_core_init_nss(struct nss
 			nss_warning("%px: Failed to update empty buffer pool config\n", nss_ctx);
 		}
 #endif
+
+#ifdef NSS_DRV_SHAPER_ENABLE
+		ret = nss_n2h_cfg_qos_mem_size(nss_ctx, qos_mem_size);
+		if (ret != NSS_TX_SUCCESS) {
+			nss_warning("%px: Failed to update QoS memory pool config\n", nss_ctx);
+		}
+#endif
+#endif /* NSS_DATA_PLANE_GENERIC_SUPPORT */
+
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+	if (nss_data_plane_lite_schedule_registration()) {
+		nss_data_plane_lite_register(nss_ctx);
+#endif
 	} else {
 		spin_lock_bh(&nss_top->lock);
 		nss_ctx->state = NSS_CORE_STATE_UNINITIALIZED;
 		spin_unlock_bh(&nss_top->lock);
 	}
+#endif /* NSS_DATA_PLANE_GENERIC_SUPPORT || NSS_DATA_PLANE_LITE_SUPPORT */
 }
 
 /*
@@ -2211,6 +2283,15 @@ static void nss_core_handle_cause_nonque
 #endif
 	}
 
+#if defined(NSS_DRV_EDMA_LITE_ENABLE)
+		/*
+		 * check if point offload it enabled; if yes then send message
+		 */
+		if (nss_edma_lite_enabled(nss_ctx) && !nss_edma_lite_is_configured()) {
+			nss_edma_lite_msg_cfg_map(nss_ctx);
+		}
+#endif
+
 	/*
 	 * TODO: find better mechanism to handle empty buffers
 	 */
@@ -3025,48 +3106,52 @@ int32_t nss_core_send_buffer(struct nss_
 	 * Take a lock for queue
 	 */
 	spin_lock_bh(&h2n_desc_ring->lock);
-
-	/*
-	 * We need to work out if there's sufficent space in our transmit descriptor
-	 * ring to place all the segments of a nbuf.
-	 */
-	NSS_CORE_DMA_CACHE_MAINT((void *)&if_map->h2n_nss_index[qid], sizeof(uint32_t), DMA_FROM_DEVICE);
-	NSS_CORE_DSB();
-	nss_index = if_map->h2n_nss_index[qid];
-
+	nss_index = h2n_desc_ring->nss_index_local;
 	hlos_index = h2n_desc_ring->hlos_index;
-
 	count = ((nss_index - hlos_index - 1) + size) & (mask);
 
+	/*
+	 * If local index shows that there is not enough space in the ring,
+	 * Read the actual index from the consumer's generation (NSS-FW).
+	 */
 	if (unlikely(count < (segments + 1))) {
 		/*
-		 * NOTE: tx_q_full_cnt and TX_STOPPED flags will be used
-		 *	when we will add support for DESC Q congestion management
-		 *	in future
-		 */
-		h2n_desc_ring->tx_q_full_cnt++;
-		h2n_desc_ring->flags |= NSS_H2N_DESC_RING_FLAGS_TX_STOPPED;
-		spin_unlock_bh(&h2n_desc_ring->lock);
-		nss_warning("%px: Data/Command Queue full reached", nss_ctx);
+		 * We need to work out if there's sufficent space in our transmit descriptor
+		 * ring to place all the segments of a nbuf.
+		 */
+		NSS_CORE_DMA_CACHE_MAINT((void *)&if_map->h2n_nss_index[qid], sizeof(uint32_t), DMA_FROM_DEVICE);
+		NSS_CORE_DSB();
+		nss_index = if_map->h2n_nss_index[qid];
+		h2n_desc_ring->nss_index_local = nss_index;
+		count = ((nss_index - hlos_index - 1) + size) & (mask);
+		if (unlikely(count < (segments + 1))) {
+			/*
+			 * NOTE: tx_q_full_cnt and TX_STOPPED flags will be used
+			 *	when we will add support for DESC Q congestion management
+			 *	in future
+			 */
+			h2n_desc_ring->tx_q_full_cnt++;
+			h2n_desc_ring->flags |= NSS_H2N_DESC_RING_FLAGS_TX_STOPPED;
+			spin_unlock_bh(&h2n_desc_ring->lock);
+			nss_warning("%px: Data/Command Queue full reached", nss_ctx);
 
 #if (NSS_PKT_STATS_ENABLED == 1)
-		if (nss_ctx->id == NSS_CORE_0) {
-			NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_0]);
-		} else if (nss_ctx->id == NSS_CORE_1) {
-			NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_1]);
-		} else {
-			nss_warning("%px: Invalid nss core: %d\n", nss_ctx, nss_ctx->id);
-		}
+			if (nss_ctx->id == NSS_CORE_0) {
+				NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_0]);
+			} else if (nss_ctx->id == NSS_CORE_1) {
+				NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_1]);
+			} else {
+				nss_warning("%px: Invalid nss core: %d\n", nss_ctx, nss_ctx->id);
+			}
 #endif
+			/*
+			 * Enable de-congestion interrupt from NSS
+			 */
+			nss_hal_enable_interrupt(nss_ctx, nss_ctx->int_ctx[0].shift_factor, NSS_N2H_INTR_TX_UNBLOCKED);
 
-		/*
-		 * Enable de-congestion interrupt from NSS
-		 */
-		nss_hal_enable_interrupt(nss_ctx, nss_ctx->int_ctx[0].shift_factor, NSS_N2H_INTR_TX_UNBLOCKED);
-
-		return NSS_CORE_STATUS_FAILURE_QUEUE;
+			return NSS_CORE_STATUS_FAILURE_QUEUE;
+		}
 	}
-
 	desc = &desc_ring[hlos_index];
 
 	/*
--- a/nss_core.h
+++ b/nss_core.h
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -38,8 +41,10 @@
 #include "nss_phys_if.h"
 #include "nss_hlos_if.h"
 #include "nss_oam.h"
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
 #include "nss_gmac_stats.h"
+#endif
 #include "nss_meminfo.h"
 #include "nss_stats.h"
 
@@ -186,7 +191,7 @@ static inline void nss_core_dma_cache_ma
 /*
  * NSS maximum IRQ per interrupt instance/core
  */
-#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT)
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ95XX_SUPPORT)
 #define NSS_MAX_IRQ_PER_INSTANCE 6
 #define NSS_MAX_IRQ_PER_CORE 10	/* must match with NSS_HAL_N2H_INTR_PURPOSE_MAX */
 #elif defined(NSS_HAL_IPQ50XX_SUPPORT)
@@ -389,6 +394,7 @@ struct hlos_n2h_desc_ring {
 struct hlos_h2n_desc_rings {
 	struct h2n_desc_if_instance desc_ring;	/* Descriptor ring */
 	uint32_t hlos_index;
+	uint32_t nss_index_local;		/* Index number for the next descriptor (NSS owned) */
 	spinlock_t lock;			/* Lock to save from simultaneous access */
 	uint32_t flags;				/* Flags */
 	uint64_t tx_q_full_cnt;			/* Descriptor queue full count */
@@ -486,6 +492,7 @@ struct nss_ctx_instance {
 					/* Service code callbacks */
 	void *service_code_ctx[NSS_MAX_SERVICE_CODE];
 					/* Service code callback contexts */
+	void *edma_lite_ctx;			/* EDMA lite context */
 	spinlock_t decongest_cb_lock;	/* Lock to protect queue decongestion cb table */
 	uint16_t phys_if_mtu[NSS_MAX_PHYSICAL_INTERFACES];
 					/* Current MTU value of physical interface */
@@ -569,6 +576,8 @@ struct nss_top_instance {
 	uint8_t wmdb_handler_id;
 	uint8_t dma_handler_id;
 	uint8_t udp_st_handler_id;
+	uint8_t edma_lite_handler_id[NSS_MAX_CORES];
+	uint8_t trustsec_rx_handler_id;
 
 	/*
 	 * Data/Message callbacks for various interfaces
@@ -663,8 +672,10 @@ struct nss_top_instance {
 	 */
 	atomic64_t stats_drv[NSS_DRV_STATS_MAX];
 					/* Hlos driver statistics */
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	uint64_t stats_gmac[NSS_MAX_PHYSICAL_INTERFACES][NSS_GMAC_STATS_MAX];
 					/* GMAC statistics */
+#endif
 	uint64_t stats_node[NSS_MAX_NET_INTERFACES][NSS_STATS_NODE_MAX];
 					/* IPv4 statistics per interface */
 	bool nss_hal_common_init_done;
@@ -677,8 +688,10 @@ struct nss_top_instance {
 	 */
 	uint64_t last_rx_jiffies;	/* Time of the last RX message from the NA in jiffies */
 	struct nss_hal_ops *hal_ops;	/* nss_hal ops for this target platform */
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	struct nss_data_plane_ops *data_plane_ops;
 					/* nss_data_plane ops for this target platform */
+#endif
 };
 
 #if (NSS_PKT_STATS_ENABLED == 1)
@@ -906,6 +919,10 @@ struct nss_platform_data {
 				/* Does this core handle mirror? */
 	enum nss_feature_enabled udp_st_enabled;
 				/* Does this core handle udp st? */
+	enum nss_feature_enabled edma_lite_enabled;
+				/* Does this core handle EDMA lite? */
+	enum nss_feature_enabled trustsec_enabled;
+				/* Does this core handle TrustSec? */
 };
 #endif
 
@@ -956,6 +973,8 @@ extern uint32_t nss_core_unregister_hand
 extern void nss_core_init_handlers(struct nss_ctx_instance *nss_ctx);
 void nss_core_update_max_ipv4_conn(int conn);
 void nss_core_update_max_ipv6_conn(int conn);
+void nss_core_update_qos_mem_size(int size);
+int nss_core_get_qos_mem_size(void);
 extern void nss_core_register_subsys_dp(struct nss_ctx_instance *nss_ctx, uint32_t if_num,
 					nss_phys_if_rx_callback_t cb,
 					nss_phys_if_rx_ext_data_callback_t ext_cb,
@@ -963,6 +982,7 @@ extern void nss_core_register_subsys_dp(
 					uint32_t features);
 extern void nss_core_unregister_subsys_dp(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 void nss_core_set_subsys_dp_type(struct nss_ctx_instance *nss_ctx, struct net_device *ndev, uint32_t if_num, uint32_t type);
+extern bool nss_core_is_mq_enabled(void);
 
 static inline nss_if_rx_msg_callback_t nss_core_get_msg_handler(struct nss_ctx_instance *nss_ctx, uint32_t interface)
 {
@@ -1034,5 +1054,6 @@ extern void nss_ppe_free(void);
  */
 extern nss_tx_status_t nss_n2h_cfg_empty_pool_size(struct nss_ctx_instance *nss_ctx, uint32_t pool_sz);
 extern nss_tx_status_t nss_n2h_paged_buf_pool_init(struct nss_ctx_instance *nss_ctx);
+extern nss_tx_status_t nss_n2h_cfg_qos_mem_size(struct nss_ctx_instance *nss_ctx, uint32_t pool_sz);
 
 #endif /* __NSS_CORE_H */
--- a/nss_coredump.c
+++ b/nss_coredump.c
@@ -1,6 +1,8 @@
 /*
  **************************************************************************
  * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -47,7 +49,8 @@ static struct workqueue_struct *coredump
  */
 static void nss_coredump_wait(struct work_struct *work)
 {
-	panic("did not get all coredump finished signals\n");
+	if (!(nss_cmd_buf.coredump & 0xFFFFFFFE))
+		panic("did not get all coredump finished signals\n");
 }
 
 /*
--- a/nss_crypto_cmn.c
+++ b/nss_crypto_cmn.c
@@ -226,6 +226,12 @@ nss_tx_status_t nss_crypto_cmn_tx_msg_sy
 	 * further details read Linux/Documentation/memory-barrier.txt
 	 */
 	smp_rmb();
+
+	if (msg->cm.response != NSS_CMN_RESPONSE_ACK) {
+		up(&pvt->sem);
+		return NSS_TX_FAILURE;
+	}
+
 	up(&pvt->sem);
 
 	return NSS_TX_SUCCESS;
--- a/nss_dynamic_interface.c
+++ b/nss_dynamic_interface.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -320,7 +323,9 @@ nss_tx_status_t nss_dynamic_interface_de
 void nss_dynamic_interface_register_handler(struct nss_ctx_instance *nss_ctx)
 {
 	nss_core_register_handler(nss_ctx, NSS_DYNAMIC_INTERFACE, nss_dynamic_interface_handler, NULL);
-	nss_dynamic_interface_stats_dentry_create();
+	if (nss_ctx->id == NSS_CORE_0) {
+		nss_dynamic_interface_stats_dentry_create();
+	}
 }
 
 /*
--- a/nss_hal/include/nss_hal.h
+++ b/nss_hal/include/nss_hal.h
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2013, 2016-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -49,6 +52,9 @@ extern struct nss_hal_ops nss_hal_ipq50x
 #if defined(NSS_HAL_FSM9010_SUPPORT)
 extern struct nss_hal_ops nss_hal_fsm9010_ops;
 #endif
+#if defined(NSS_HAL_IPQ95XX_SUPPORT)
+extern struct nss_hal_ops nss_hal_ipq95xx_ops;
+#endif
 
 #define NSS_HAL_SUPPORTED_INTERRUPTS (NSS_N2H_INTR_EMPTY_BUFFER_QUEUE | \
 					NSS_N2H_INTR_DATA_QUEUE_0 | \
--- a/nss_hal/include/nss_regs.h
+++ b/nss_hal/include/nss_regs.h
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2013, 2015-2017, 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -38,16 +41,26 @@
 #define NSS_REGS_C2C_INTR_CLR_OFFSET		0x001c
 #define NSS_REGS_N2H_INTR_STATUS_OFFSET		0x0020
 #define NSS_REGS_N2H_INTR_SET_OFFSET		0x0024
+
+#if defined(NSS_HAL_IPQ95XX_SUPPORT)
+#define NSS_REGS_CORE_INT_STAT0_ENABLE_OFFSET	0x0028
+#define NSS_REGS_CORE_INT_STAT1_ENABLE_OFFSET	0x002c
+#define NSS_REGS_CORE_INT_STAT2_ENABLE_OFFSET	0x0030
+#define NSS_REGS_CORE_INT_STAT3_ENABLE_OFFSET	0x0034
+#elif defined(NSS_HAL_FSM9010_SUPPORT) || defined(NSS_HAL_IPQ806X_SUPPORT)
 #define NSS_REGS_N2H_INTR_CLR_OFFSET		0x0028
 #define NSS_REGS_N2H_INTR_MASK_OFFSET		0x002c
 #define NSS_REGS_N2H_INTR_MASK_SET_OFFSET	0x0030
 #define NSS_REGS_N2H_INTR_MASK_CLR_OFFSET	0x0034
+#endif
+
 #define NSS_REGS_CORE_INT_STAT0_TYPE_OFFSET	0x0038
 #define NSS_REGS_CORE_INT_STAT1_TYPE_OFFSET	0x003c
 #define NSS_REGS_CORE_INT_STAT2_TYPE_OFFSET	0x0040
 #define NSS_REGS_CORE_INT_STAT3_TYPE_OFFSET	0x0044
 #define NSS_REGS_CORE_IFETCH_RANGE_OFFSET	0x0048
 
+
 /*
  * FPB register offsets
  */
--- a/nss_hal/ipq806x/nss_hal_pvt.c
+++ b/nss_hal/ipq806x/nss_hal_pvt.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2013, 2015-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -978,12 +981,12 @@ static int __nss_hal_clock_configure(str
 	 * Check if turbo is supported
 	 */
 	if (npd->turbo_frequency) {
-		nss_info_always("nss_driver - Turbo Support %d\n", npd->turbo_frequency);
+		nss_info("nss_driver - Turbo Support %d\n", npd->turbo_frequency);
 #if (NSS_PM_SUPPORT == 1)
 		nss_pm_set_turbo();
 #endif
 	} else {
-		nss_info_always("nss_driver - Turbo No Support %d\n", npd->turbo_frequency);
+		nss_info("nss_driver - Turbo No Support %d\n", npd->turbo_frequency);
 	}
 
 	/*
@@ -1082,26 +1085,26 @@ clk_complete:
 		}
 	}
 
-	nss_info_always("Supported Frequencies - ");
+	nss_info("Supported Frequencies - ");
 	for (i = 0; i < NSS_FREQ_MAX_SCALE; i++) {
 		if (nss_runtime_samples.freq_scale[i].frequency == NSS_FREQ_110) {
-			nss_info_always("110Mhz ");
+			nss_info("110Mhz ");
 		} else if (nss_runtime_samples.freq_scale[i].frequency == NSS_FREQ_275) {
-			nss_info_always("275Mhz ");
+			nss_info("275Mhz ");
 		} else if (nss_runtime_samples.freq_scale[i].frequency == NSS_FREQ_550) {
-			nss_info_always("550Mhz ");
+			nss_info("550Mhz ");
 		} else if (nss_runtime_samples.freq_scale[i].frequency == NSS_FREQ_600) {
-			nss_info_always("600Mhz ");
+			nss_info("600Mhz ");
 		} else if (nss_runtime_samples.freq_scale[i].frequency == NSS_FREQ_733) {
-			nss_info_always("733Mhz ");
+			nss_info("733Mhz ");
 		} else if (nss_runtime_samples.freq_scale[i].frequency == NSS_FREQ_800) {
-			nss_info_always("800Mhz ");
+			nss_info("800Mhz ");
 		} else {
 			nss_info_always("Error\nNo Table/Invalid Frequency Found - Loading Old Tables -");
 			return -EFAULT;
 		}
 	}
-	nss_info_always("\n");
+	nss_info("\n");
 
 	/*
 	 * Set default frequency
--- a/nss_hal/nss_hal.c
+++ b/nss_hal/nss_hal.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -30,7 +33,12 @@
 #include "nss_arch.h"
 #include "nss_core.h"
 #include "nss_tx_rx_common.h"
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
+#endif
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+#include "nss_data_plane_lite.h"
+#endif
 #if (NSS_PM_SUPPORT == 1)
 #include "nss_pm.h"
 #endif
@@ -41,7 +49,6 @@
 /*
  * Macros
  */
-#define MIN_IMG_SIZE (64*1024)
 #define NSS_AP0_IMAGE "qca-nss0.bin"
 #define NSS_AP1_IMAGE "qca-nss1.bin"
 
@@ -74,10 +81,6 @@ int nss_hal_firmware_load(struct nss_ctx
 		return rc;
 	}
 
-	if (nss_fw->size < MIN_IMG_SIZE) {
-		nss_info_always("%px: nss firmware is truncated, size:%d", nss_ctx, (int)nss_fw->size);
-		return rc;
-	}
 
 	load_mem = ioremap(npd->load_addr, nss_fw->size);
 	if (!load_mem) {
@@ -86,7 +89,7 @@ int nss_hal_firmware_load(struct nss_ctx
 		return rc;
 	}
 
-	nss_info_always("nss_driver - fw of size %d  bytes copied to load addr: %x, nss_id : %d\n", (int)nss_fw->size, npd->load_addr, nss_dev->id);
+	nss_info("nss_driver - fw of size %d  bytes copied to load addr: %x, nss_id : %d\n", (int)nss_fw->size, npd->load_addr, nss_dev->id);
 	memcpy_toio(load_mem, nss_fw->data, nss_fw->size);
 	release_firmware(nss_fw);
 	iounmap(load_mem);
@@ -139,7 +142,10 @@ void nss_hal_dt_parse_features(struct de
 	npd->match_enabled = of_property_read_bool(np, "qcom,match-enabled");
 	npd->mirror_enabled = of_property_read_bool(np, "qcom,mirror-enabled");
 	npd->udp_st_enabled = of_property_read_bool(np, "qcom,udp-st-enabled");
+	npd->edma_lite_enabled = of_property_read_bool(np, "qcom,edma-lite-enabled");
+	npd->trustsec_enabled = of_property_read_bool(np, "qcom,trustsec-enabled");
 }
+
 /*
  * nss_hal_clean_up_irq()
  */
@@ -360,6 +366,7 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
+#ifdef NSS_DRV_IPV4_ENABLE
 	if (npd->ipv4_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->ipv4_handler_id = nss_dev->id;
 		nss_ipv4_register_handler();
@@ -368,10 +375,15 @@ int nss_hal_probe(struct platform_device
 		nss_top->edma_handler_id = nss_dev->id;
 		nss_edma_register_handler();
 #endif
+
+#ifdef NSS_DRV_ETH_RX_ENABLE
 		nss_eth_rx_register_handler(nss_ctx);
+#endif
+
 #ifdef NSS_DRV_LAG_ENABLE
 		nss_lag_register_handler();
 #endif
+
 #ifdef NSS_DRV_TRUSTSEC_ENABLE
 		nss_top->trustsec_tx_handler_id = nss_dev->id;
 		nss_trustsec_tx_register_handler();
@@ -382,6 +394,17 @@ int nss_hal_probe(struct platform_device
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_H2N] = nss_dev->id;
 	}
+#endif
+
+#ifdef NSS_DRV_TRUSTSEC_RX_ENABLE
+	if (npd->trustsec_enabled == NSS_FEATURE_ENABLED) {
+		nss_top->trustsec_rx_handler_id = nss_dev->id;
+		nss_trustsec_rx_register_handler();
+
+		nss_top->trustsec_tx_handler_id = nss_dev->id;
+		nss_trustsec_tx_register_handler();
+	}
+#endif
 
 #ifdef NSS_DRV_CAPWAP_ENABLE
 	if (npd->capwap_enabled == NSS_FEATURE_ENABLED) {
@@ -391,20 +414,26 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
+#ifdef NSS_DRV_IPV4_REASM_ENABLE
 	if (npd->ipv4_reasm_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->ipv4_reasm_handler_id = nss_dev->id;
 		nss_ipv4_reasm_register_handler();
 	}
+#endif
 
+#ifdef NSS_DRV_IPV6_ENABLE
 	if (npd->ipv6_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->ipv6_handler_id = nss_dev->id;
 		nss_ipv6_register_handler();
 	}
 
+#ifdef NSS_DRV_IPV6_REASM_ENABLE
 	if (npd->ipv6_reasm_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->ipv6_reasm_handler_id = nss_dev->id;
 		nss_ipv6_reasm_register_handler();
 	}
+#endif
+#endif
 
 #ifdef NSS_DRV_CRYPTO_ENABLE
 	/*
@@ -413,7 +442,7 @@ int nss_hal_probe(struct platform_device
 	 */
 	if (npd->crypto_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->crypto_handler_id = nss_dev->id;
-#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT)
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT) || defined(NSS_HAL_IPQ95XX_SUPPORT)
 		nss_crypto_cmn_register_handler();
 #else
 		nss_top->crypto_enabled = 1;
@@ -460,10 +489,12 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
+#ifdef NSS_DRV_PPPOE_ENABLE
 	if (npd->pppoe_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->pppoe_handler_id = nss_dev->id;
 		nss_pppoe_register_handler();
 	}
+#endif
 
 #ifdef NSS_DRV_PPE_ENABLE
 	if (npd->ppe_enabled == NSS_FEATURE_ENABLED) {
@@ -483,7 +514,7 @@ int nss_hal_probe(struct platform_device
 #ifdef NSS_DRV_DTLS_ENABLE
 	if (npd->dtls_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->dtls_handler_id = nss_dev->id;
-#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT)
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT) || defined(NSS_HAL_IPQ95XX_SUPPORT)
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_INNER] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_OUTER] = nss_dev->id;
 		nss_dtls_cmn_register_handler();
@@ -558,13 +589,15 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
+#ifdef NSS_DRV_WIFIOFFLOAD_ENABLE
 	if (npd->wifioffload_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->wifi_handler_id = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_VAP] = nss_dev->id;
 		nss_wifi_register_handler();
 		nss_wifili_register_handler();
+#ifdef NSS_DRV_WIFI_EXT_VDEV_ENABLE
 		nss_wifi_ext_vdev_register_handler();
-		nss_wifi_mesh_init();
+#endif
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_INTERNAL] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL0] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL1] = nss_dev->id;
@@ -584,6 +617,7 @@ int nss_hal_probe(struct platform_device
 		 */
 		nss_wifili_thread_scheme_db_init(nss_dev->id);
 	}
+#endif
 
 #ifdef NSS_DRV_OAM_ENABLE
 	if (npd->oam_enabled == NSS_FEATURE_ENABLED) {
@@ -592,17 +626,21 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
+#ifdef NSS_DRV_BRIDGE_ENABLE
 	if (npd->bridge_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->bridge_handler_id = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_BRIDGE] = nss_dev->id;
 		nss_bridge_init();
 	}
+#endif
 
+#ifdef NSS_DRV_VLAN_ENABLE
 	if (npd->vlan_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->vlan_handler_id = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_VLAN] = nss_dev->id;
 		nss_vlan_register_handler();
 	}
+#endif
 
 #ifdef NSS_DRV_QVPN_ENABLE
 #if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT)
@@ -703,8 +741,19 @@ int nss_hal_probe(struct platform_device
 		nss_freq_init_cpu_usage();
 #endif
 
+#ifdef NSS_DRV_LSO_RX_ENABLE
 		nss_lso_rx_register_handler(nss_ctx);
+#endif
+	}
+
+#ifdef NSS_DRV_EDMA_LITE_ENABLE
+	if (npd->edma_lite_enabled == NSS_FEATURE_ENABLED) {
+		nss_top->edma_lite_handler_id[nss_ctx->id] = nss_ctx->id;
+		nss_edma_lite_register_handler(nss_ctx);
+	} else {
+		nss_top->edma_lite_handler_id[nss_ctx->id] = -1;
 	}
+#endif
 
 	nss_top->frequency_handler_id = nss_dev->id;
 
@@ -803,7 +852,13 @@ int nss_hal_remove(struct platform_devic
 	/*
 	 * nss-drv is exiting, unregister and restore host data plane
 	 */
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_top->data_plane_ops->data_plane_unregister();
+#endif
+
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+	nss_data_plane_lite_unregister();
+#endif
 
 #if (NSS_FABRIC_SCALING_SUPPORT == 1)
 	fab_scaling_unregister(nss_core0_clk);
--- a/nss_hlos_if.h
+++ b/nss_hlos_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2019, 2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -33,7 +33,11 @@
  */
 #if defined (NSS_MEM_PROFILE_LOW)
 #define NSS_DEFAULT_NUM_CONN			512		/* Default number of connections for IPv4 and IPv6 each, for low memory profile */
+#if defined (NSS_DRV_IPV6_ENABLE)
 #define NSS_MAX_TOTAL_NUM_CONN_IPV4_IPV6	1024		/* MAX Connection shared between IPv4 and IPv6 for low memory profile */
+#else
+#define NSS_MAX_TOTAL_NUM_CONN_IPV4_IPV6	512		/* MAX Connection for IPv4 for low memory profile */
+#endif
 #define NSS_LOW_MEM_EMPTY_POOL_BUF_SZ		4096		/* Default empty buffer pool size for low profile */
 #elif defined (NSS_MEM_PROFILE_MEDIUM)
 #define NSS_DEFAULT_NUM_CONN			2048		/* Default number of connections for IPv4 and IPv6 each, for medium memory profile */
--- a/nss_if.c
+++ b/nss_if.c
@@ -160,10 +160,10 @@ nss_tx_status_t nss_if_tx_buf(struct nss
 }
 
 /*
- * nss_if_tx_msg()
- *	Transmit a message to the specific interface on this core.
+ * nss_if_tx_msg_with_size()
+ *	Transmit a message to the specific interface on this core with a specified size.
  */
-nss_tx_status_t nss_if_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim)
+nss_tx_status_t nss_if_tx_msg_with_size(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim, uint32_t size)
 {
 	struct nss_cmn_msg *ncm = &nim->cm;
 	struct net_device *dev;
@@ -198,7 +198,19 @@ nss_tx_status_t nss_if_tx_msg(struct nss
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
-	return nss_core_send_cmd(nss_ctx, nim, sizeof(*nim), NSS_NBUF_PAYLOAD_SIZE);
+	return nss_core_send_cmd(nss_ctx, nim, sizeof(*nim), size);
+}
+EXPORT_SYMBOL(nss_if_tx_msg_with_size);
+
+/*
+ * nss_if_tx_msg()
+ *	Transmit a message to the specific interface on this core.
+ */
+nss_tx_status_t nss_if_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim)
+{
+	NSS_VERIFY_CTX_MAGIC(nss_ctx);
+
+	return nss_if_tx_msg_with_size(nss_ctx, nim, NSS_NBUF_PAYLOAD_SIZE);
 }
 
 /*
--- a/nss_init.c
+++ b/nss_init.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -24,7 +27,12 @@
 #include "nss_pm.h"
 #endif
 #include "nss_tx_rx_common.h"
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
+#endif
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+#include "nss_data_plane_lite.h"
+#endif
 #include "nss_capwap.h"
 #include "nss_strings.h"
 
@@ -633,10 +641,24 @@ static struct ctl_table_header *nss_dev_
  */
 static int __init nss_init(void)
 {
+#if defined(NSS_DRV_POINT_OFFLOAD)
+	struct device_node *pof = NULL;
+#endif
+
+
 #if (NSS_DT_SUPPORT == 1)
 	struct device_node *cmn = NULL;
 #endif
-	nss_info("Init NSS driver");
+
+#if defined(NSS_DRV_POINT_OFFLOAD)
+	pof = of_find_node_by_name(NULL, "reg_update");
+	if ((!pof) || (!of_property_read_bool(pof, "ubi_core_enable"))) {
+		nss_info_always("UBI is not enabled. Disable qca-nss-drv\n");
+		return 0;
+	}
+#endif
+
+nss_info("Init NSS driver");
 
 #if (NSS_DT_SUPPORT == 1)
 	/*
@@ -655,14 +677,18 @@ static int __init nss_init(void)
 #if defined(NSS_HAL_IPQ806X_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq8064") || of_machine_is_compatible("qcom,ipq8062")) {
 		nss_top_main.hal_ops = &nss_hal_ipq806x_ops;
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_gmac_ops;
+#endif
 		nss_top_main.num_nss = 2;
 	}
 #endif
 #if defined(NSS_HAL_IPQ807x_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq807x") || of_machine_is_compatible("qcom,ipq8074")) {
 		nss_top_main.hal_ops = &nss_hal_ipq807x_ops;
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_ops;
+#endif
 #if defined(NSS_MEM_PROFILE_LOW)
 		nss_top_main.num_nss = 1;
 #else
@@ -673,21 +699,35 @@ static int __init nss_init(void)
 #if defined(NSS_HAL_IPQ60XX_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq6018")) {
 		nss_top_main.hal_ops = &nss_hal_ipq60xx_ops;
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_ops;
+#endif
 		nss_top_main.num_nss = 1;
 	}
 #endif
 #if defined(NSS_HAL_IPQ50XX_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq5018")) {
 		nss_top_main.hal_ops = &nss_hal_ipq50xx_ops;
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_ops;
+#endif
+		nss_top_main.num_nss = 1;
+	}
+#endif
+
+#if defined(NSS_HAL_IPQ95XX_SUPPORT)
+	if (of_machine_is_compatible("qcom,ipq9574-emulation") || of_machine_is_compatible("qcom,ipq9574")) {
+		nss_top_main.hal_ops = &nss_hal_ipq95xx_ops;
 		nss_top_main.num_nss = 1;
 	}
 #endif
+
 #if defined(NSS_HAL_FSM9010_SUPPORT)
 	if (of_machine_is_compatible("qcom,fsm9010")) {
 		nss_top_main.hal_ops = &nss_hal_fsm9010_ops;
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_gmac_ops;
+#endif
 		nss_top_main.num_nss = 1;
 	}
 #endif
@@ -700,7 +740,9 @@ static int __init nss_init(void)
 	 * For banana, only ipq806x is supported
 	 */
 	nss_top_main.hal_ops = &nss_hal_ipq806x_ops;
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_top_main.data_plane_ops = &nss_data_plane_gmac_ops;
+#endif
 	nss_top_main.num_nss = 2;
 
 #endif /* NSS_DT_SUPPORT */
@@ -709,11 +751,20 @@ static int __init nss_init(void)
 	/*
 	 * Initialize data_plane workqueue
 	 */
+
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	if (nss_data_plane_init_delay_work()) {
 		nss_warning("Error initializing nss_data_plane_workqueue\n");
 		return -EFAULT;
 	}
+#endif
 
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+	if (nss_data_plane_lite_init_delay_work()){
+		nss_warning("Error initializing nss_data_plane_lite_workqueue\n");
+		return -EFAULT;
+	}
+#endif
 	/*
 	 * Enable spin locks
 	 */
@@ -739,8 +790,12 @@ static int __init nss_init(void)
 	/*
 	 * Registering sysctl for ipv4/6 specific config.
 	 */
+#ifdef NSS_DRV_IPV4_ENABLE
 	nss_ipv4_register_sysctl();
+#endif
+#ifdef NSS_DRV_IPV6_ENABLE
 	nss_ipv6_register_sysctl();
+#endif
 
 	/*
 	 * Registering sysctl for n2h specific config.
@@ -776,7 +831,9 @@ static int __init nss_init(void)
 	/*
 	 * Registering sysctl for pppoe specific config.
 	 */
+#ifdef NSS_DRV_PPPOE_ENABLE
 	nss_pppoe_register_sysctl();
+#endif
 
 	/*
 	 * Setup Runtime Sample values
@@ -871,6 +928,13 @@ static int __init nss_init(void)
 #endif
 
 	/*
+	 * Init Wi-Fi mesh
+	 */
+#ifdef NSS_DRV_WIFI_MESH_ENABLE
+	nss_wifi_mesh_init();
+#endif
+
+	/*
 	 * Register platform_driver
 	 */
 	return platform_driver_register(&nss_driver);
@@ -907,22 +971,32 @@ static void __exit nss_cleanup(void)
 	/*
 	 * Unregister pppoe specific sysctl
 	 */
+#ifdef NSS_DRV_PPPOE_ENABLE
 	nss_pppoe_unregister_sysctl();
+#endif
 
 	/*
-	 * Unregister ipv4/6 specific sysctl
+	 * Unregister ipv4/6 specific sysctl and free allocated to connection tables
 	 */
+#ifdef NSS_DRV_IPV4_ENABLE
 	nss_ipv4_unregister_sysctl();
-	nss_ipv6_unregister_sysctl();
-
-	/*
-	 * Free Memory allocated for connection tables
-	 */
 	nss_ipv4_free_conn_tables();
+#endif
+
+#ifdef NSS_DRV_IPV6_ENABLE
+	nss_ipv6_unregister_sysctl();
 	nss_ipv6_free_conn_tables();
+#endif
 
 	nss_project_unregister_sysctl();
+
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_data_plane_destroy_delay_work();
+#endif
+
+#ifdef NSS_DATA_PLANE_LITE_SUPPORT
+	nss_data_plane_lite_destroy_delay_work();
+#endif
 
 	/*
 	 * cleanup ppe on supported platform
--- a/nss_ipv4.c
+++ b/nss_ipv4.c
@@ -70,6 +70,20 @@ static inline void nss_ipv4_dscp_map_usa
 }
 
 /*
+ * nss_ipv4_get_total_conn_count()
+ *	 Returns the sum of IPv4 and IPv6 connections.
+ */
+static uint32_t nss_ipv4_get_total_conn_count(int ipv4_num_conn)
+{
+
+#ifdef NSS_DRV_IPV6_ENABLE
+	return ipv4_num_conn + nss_ipv6_conn_cfg;
+#else
+	return ipv4_num_conn;
+#endif
+}
+
+/*
  * nss_ipv4_rx_msg_handler()
  *	Handle NSS -> HLOS messages for IPv4 bridge/route
  */
@@ -532,7 +546,8 @@ int nss_ipv4_update_conn_count(int ipv4_
 	 * Min. value should be at least 256 connections. This is the
 	 * minimum connections we will support for each of them.
 	 */
-	sum_of_conn = ipv4_num_conn + nss_ipv6_conn_cfg;
+	sum_of_conn = nss_ipv4_get_total_conn_count(ipv4_num_conn);
+
 	if ((ipv4_num_conn & NSS_NUM_CONN_QUANTA_MASK) ||
 		(sum_of_conn > NSS_MAX_TOTAL_NUM_CONN_IPV4_IPV6) ||
 		(ipv4_num_conn < NSS_MIN_NUM_CONN)) {
--- a/nss_ipv4_strings.c
+++ b/nss_ipv4_strings.c
@@ -109,6 +109,7 @@ struct nss_stats_info nss_ipv4_strings_e
 	{"icmp_ipv4_gre_hdr_incomplete"		, NSS_STATS_TYPE_EXCEPTION},
 	{"icmp_ipv4_esp_hdr_incomplete"		, NSS_STATS_TYPE_EXCEPTION},
 	{"emesh_prio_mismatch"			, NSS_STATS_TYPE_EXCEPTION},
+	{"mc_ucast_dmac_failure"		, NSS_STATS_TYPE_EXCEPTION},
 };
 
 /*
--- a/nss_ipv6_strings.c
+++ b/nss_ipv6_strings.c
@@ -86,6 +86,7 @@ struct nss_stats_info nss_ipv6_strings_e
 	{"icmp_gre_header_incomplete"			, NSS_STATS_TYPE_EXCEPTION},
 	{"icmp_esp_header_incomplete"			, NSS_STATS_TYPE_EXCEPTION},
 	{"emesh_prio_mismatch"				, NSS_STATS_TYPE_EXCEPTION},
+	{"mc_ucast_dmac_failure"			, NSS_STATS_TYPE_EXCEPTION},
 };
 
 /*
--- a/nss_meminfo.c
+++ b/nss_meminfo.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -408,7 +409,7 @@ static bool nss_meminfo_init_block_lists
 
 		if (strcmp(r->name, "profile_dma_ctrl") == 0) {
 			mem_ctx->sdma_ctrl = kern_addr;
-		nss_info_always("%px: set sdma %px\n", nss_ctx, kern_addr);
+		nss_info("%px: set sdma %px\n", nss_ctx, kern_addr);
 		}
 
 		/*
@@ -535,6 +536,13 @@ static bool nss_meminfo_configure_n2h_h2
 	}
 
 	/*
+	 * Returning true allows to execute firmware bin
+	 */
+	if (!mem_ctx->if_map) {
+		return true;
+	}
+
+	/*
 	 * Bring a fresh copy of if_map from memory in order to read it correctly.
 	 */
 	if_map = mem_ctx->if_map;
@@ -793,6 +801,6 @@ bool nss_meminfo_init(struct nss_ctx_ins
 
 	nss_meminfo_init_debugfs(nss_ctx);
 
-	nss_info_always("%px: meminfo init succeed\n", nss_ctx);
+	nss_info("%px: meminfo init succeed\n", nss_ctx);
 	return true;
 }
--- a/nss_n2h.c
+++ b/nss_n2h.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -30,6 +33,12 @@
 #define NSS_N2H_DEFAULT_EMPTY_POOL_BUF_SZ	8192
 #define NSS_N2H_TX_TIMEOUT 3000 /* 3 Seconds */
 
+/*
+ * Allocate shaper pool memory in multiple chunk of PAGE_SIZE
+ */
+#define NSS_N2H_MIN_QOS_MEM_POOL_SZ		1
+#define NSS_N2H_QOS_MEM_POOL_SZ_MB(size)		(size * 1024 * 1024)
+
 int nss_n2h_empty_pool_buf_cfg[NSS_MAX_CORES] __read_mostly = {-1, -1};
 int nss_n2h_empty_paged_pool_buf_cfg[NSS_MAX_CORES] __read_mostly = {-1, -1};
 int nss_n2h_water_mark[NSS_MAX_CORES][2] __read_mostly = {{-1, -1}, {-1, -1} };
@@ -41,6 +50,7 @@ int nss_n2h_core0_add_buf_pool_size __re
 int nss_n2h_core1_add_buf_pool_size __read_mostly;
 int nss_n2h_queue_limit[NSS_MAX_CORES] __read_mostly = {NSS_DEFAULT_QUEUE_LIMIT, NSS_DEFAULT_QUEUE_LIMIT};
 int nss_n2h_host_bp_config[NSS_MAX_CORES] __read_mostly;
+int nss_n2h_shaper_pool_size_cfg __read_mostly;
 
 struct nss_n2h_registered_data {
 	nss_n2h_msg_callback_t n2h_callback;
@@ -57,6 +67,9 @@ static struct nss_n2h_cfg_pvt nss_n2h_q_
 static struct nss_n2h_cfg_pvt nss_n2h_q_lim_pvt;
 static struct nss_n2h_cfg_pvt nss_n2h_host_bp_cfg_pvt;
 
+static uint32_t nss_n2h_shaper_pool_cfg_num_pages;
+static nss_tx_status_t nss_n2h_cfg_shaper_pool(struct nss_ctx_instance *nss_ctx)
+;
 /*
  * nss_n2h_interface_handler()
  *	Handle NSS -> HLOS messages for N2H node
@@ -982,6 +995,24 @@ static int nss_n2h_wifi_payloads_handler
 }
 
 /*
+ * nss_n2h_get_qos_mem_size_cfg_handler()
+ *	Gets the QoS memory pool size
+ */
+static int nss_n2h_get_qos_mem_size_cfg_handler(struct ctl_table *ctl,
+			int write, void __user *buffer,
+			size_t *lenp, loff_t *ppos)
+{
+	int ret = NSS_FAILURE;
+
+	if (!write) {
+		nss_n2h_shaper_pool_size_cfg = NSS_N2H_QOS_MEM_POOL_SZ_MB(nss_core_get_qos_mem_size());
+	}
+
+	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+	return ret;
+}
+
+/*
  * nss_n2h_update_queue_config_callback()
  *	Callback to handle the completion of queue config command
  */
@@ -1703,6 +1734,13 @@ static struct ctl_table nss_n2h_table_si
 		.mode		= 0644,
 		.proc_handler	= &nss_n2h_host_bp_cfg_core0_handler,
 	},
+	{
+		.procname		= "qos_mem_size",
+		.data			= &nss_n2h_shaper_pool_size_cfg,
+		.maxlen			= sizeof(int),
+		.mode			= 0644,
+		.proc_handler	= &nss_n2h_get_qos_mem_size_cfg_handler,
+	},
 
 	{ }
 };
@@ -1856,6 +1894,13 @@ static struct ctl_table nss_n2h_table_mu
 		.mode		= 0644,
 		.proc_handler	= &nss_n2h_host_bp_cfg_core1_handler,
 	},
+	{
+		.procname		= "qos_mem_size",
+		.data			= &nss_n2h_shaper_pool_size_cfg,
+		.maxlen			= sizeof(int),
+		.mode			= 0644,
+		.proc_handler	= &nss_n2h_get_qos_mem_size_cfg_handler,
+	},
 	{ }
 };
 
@@ -1932,6 +1977,113 @@ nss_tx_status_t nss_n2h_cfg_empty_pool_s
 	return nss_tx_status;
 }
 
+static inline void nss_n2h_shaper_pool_free(struct nss_n2h_shaper_mem_cfg_msg *nnsmcm, int num_blks)
+{
+	int blk_count;
+	for (blk_count = 0; blk_count < num_blks; blk_count++) {
+		kfree((void *)nnsmcm->pool_vaddr[blk_count]);
+	}
+}
+
+/*
+ * nss_n2h_cfg_qos_mem_size_callback()
+ *	Call back function for QoS memory pool size configuration
+ */
+static void nss_n2h_cfg_qos_mem_size_callback(void *app_data, struct nss_n2h_msg *nnm)
+{
+	struct nss_ctx_instance *nss_ctx __maybe_unused = (struct nss_ctx_instance *)app_data;
+	struct nss_n2h_shaper_mem_cfg_msg *nnsmcm = &nnm->msg.shaper_mem_cfg;
+	nnsmcm->num_blks = ntohl(nnsmcm->num_blks);
+
+	if (nnm->cm.response != NSS_CMN_RESPONSE_ACK) {
+		nss_warning("%px: Shaper pool configuration failed with error: %d\n", nss_ctx, nnm->cm.error);
+		nss_n2h_shaper_pool_free(nnsmcm, nnsmcm->num_blks);
+		return;
+	}
+
+	nss_core_update_qos_mem_size(nss_core_get_qos_mem_size() + (PAGE_SIZE * nnsmcm->num_blks));
+	nss_n2h_cfg_shaper_pool(nss_ctx);
+	nss_info("%px: shaper pool configuration success\n", nss_ctx);
+}
+
+/*
+ * nss_n2h_cfg_shaper_pool()
+ *	Config QoS memory pool in NSS FW
+ */
+static nss_tx_status_t nss_n2h_cfg_shaper_pool(struct nss_ctx_instance *nss_ctx)
+{
+	struct nss_n2h_msg nnm;
+	struct nss_n2h_shaper_mem_cfg_msg *nnsmcm;
+	nss_tx_status_t nss_tx_status;
+	int blk_count;
+
+	if (!nss_n2h_shaper_pool_cfg_num_pages) {
+		return NSS_TX_SUCCESS;
+	}
+
+	memset(&nnm, 0, sizeof(struct nss_n2h_msg));
+	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
+			NSS_TX_METADATA_TYPE_N2H_SHAPER_POOL_CFG,
+			sizeof(struct nss_n2h_shaper_mem_cfg_msg),
+			nss_n2h_cfg_qos_mem_size_callback,
+			(void *)nss_ctx);
+
+	nnsmcm = &nnm.msg.shaper_mem_cfg;
+
+	for (blk_count = 0; blk_count < MAX_PAGES_PER_MSG; blk_count++) {
+		void *kern_addr = kzalloc(PAGE_SIZE, GFP_ATOMIC);
+		if (!kern_addr) {
+			nss_warning("%px: memory allocation failed for shaper pool", nss_ctx);
+			return NSS_TX_FAILURE;
+		}
+
+		kmemleak_not_leak(kern_addr);
+		nnsmcm->pool_vaddr[blk_count] = (nss_ptr_t)kern_addr;
+		nnsmcm->pool_addr[blk_count] = dma_map_single(nss_ctx->dev, kern_addr, PAGE_SIZE, DMA_TO_DEVICE);
+	}
+
+	nnsmcm->mem_blk_size = htonl(PAGE_SIZE);
+	nnsmcm->num_blks = htonl(blk_count);
+	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
+
+	if (nss_tx_status != NSS_TX_SUCCESS) {
+		nss_n2h_shaper_pool_free(nnsmcm, blk_count);
+		nss_warning("%px: nss_tx error setting shaper pool\n", nss_ctx);
+		return NSS_TX_FAILURE;
+	}
+
+	nss_n2h_shaper_pool_cfg_num_pages--;
+	return NSS_TX_SUCCESS;
+}
+
+/*
+ * nss_n2h_cfg_qos_mem_size()
+ *	Config QoS memory pool size
+ */
+nss_tx_status_t nss_n2h_cfg_qos_mem_size(struct nss_ctx_instance *nss_ctx, uint32_t pool_sz)
+{
+	nss_info("%px: update QoS memory pool size: %dMB\n",
+		nss_ctx, pool_sz);
+
+	if (!pool_sz) {
+		nss_info("%px: No extra memory allocated for QoS memory pool",
+				nss_ctx);
+		return NSS_TX_SUCCESS;
+	}
+
+	if (pool_sz < NSS_N2H_MIN_QOS_MEM_POOL_SZ) {
+		nss_warning("%px: pool size: %d is less than minimum value allowed: %d",
+				nss_ctx, pool_sz, NSS_N2H_MIN_QOS_MEM_POOL_SZ);
+		return NSS_TX_FAILURE;
+	}
+
+	nss_n2h_shaper_pool_cfg_num_pages = ALIGN(NSS_N2H_QOS_MEM_POOL_SZ_MB(pool_sz), PAGE_SIZE)/(PAGE_SIZE * MAX_PAGES_PER_MSG);
+
+	nss_info("%px: shaper pool size:%d bytes\n", nss_ctx, NSS_N2H_QOS_MEM_POOL_SZ_MB(pool_sz));
+
+	return nss_n2h_cfg_shaper_pool(nss_ctx);
+}
+
 /*
  * nss_n2h_paged_buf_pool_init()
  *	Sends a command down to NSS to initialize paged buffer pool
@@ -2061,10 +2213,9 @@ void nss_n2h_register_handler(struct nss
 
 	if (nss_ctx->id == NSS_CORE_0) {
 		nss_n2h_stats_dentry_create();
+		nss_n2h_strings_dentry_create();
+		nss_drv_strings_dentry_create();
 	}
-	nss_n2h_strings_dentry_create();
-
-	nss_drv_strings_dentry_create();
 }
 
 /*
--- a/nss_phys_if.h
+++ b/nss_phys_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -70,6 +70,12 @@ struct nss_phys_if_estats {
 	uint32_t gmac_worst_case_ticks;	/**< Worst case iteration of the GMAC in ticks */
 	uint32_t gmac_iterations;	/**< Number of iterations around the GMAC */
 	uint32_t tx_pause_frames;	/**< Number of pause frames sent by the GMAC */
+
+	/*
+	 * On IPQ50xx, we rely on the SSDK to pull the mmc stats.
+	 * The FAL layer does not do this on IPQ806x.
+	 */
+#if defined(NSS_HAL_IPQ806X_SUPPORT)
 	uint32_t mmc_rx_overflow_errors;
 					/**< Number of RX overflow errors */
 	uint32_t mmc_rx_watchdog_timeout_errors;
@@ -94,6 +100,7 @@ struct nss_phys_if_estats {
 	uint32_t mmc_tx_single_col;	/* Number of single collisions */
 	uint32_t mmc_tx_multiple_col;	/* Number of multiple collisions */
 	uint32_t mmc_tx_octets_gb;	/* Number of good/bad octets sent*/
+#endif
 };
 
 /**
--- a/nss_profiler.c
+++ b/nss_profiler.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -97,7 +100,7 @@ nss_tx_status_t nss_profiler_if_tx_buf(v
 		return NSS_TX_FAILURE_TOO_LARGE;
 	}
 
-	npm = kzalloc(sizeof(*npm), GFP_KERNEL);
+	npm = kzalloc(sizeof(*npm), GFP_ATOMIC);
 	if (!npm) {
 		nss_warning("%px: Failed to allocate memory for message\n", nss_ctx);
 		return NSS_TX_FAILURE;
@@ -121,6 +124,7 @@ void *nss_profiler_alloc_dma(struct nss_
 {
 	int size;
 	void *kaddr;
+	dma_addr_t dma_addr;
 	struct nss_profile_sdma_producer *dma;
 	struct nss_profile_sdma_ctrl *ctrl = (struct nss_profile_sdma_ctrl *)nss_ctx->meminfo_ctx.sdma_ctrl;
 	if (!ctrl)
@@ -132,7 +136,13 @@ void *nss_profiler_alloc_dma(struct nss_
 	kaddr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 
 	if (kaddr) {
-		dma->desc_ring = dma_map_single(nss_ctx->dev, kaddr, size, DMA_FROM_DEVICE);
+		dma_addr = dma_map_single(nss_ctx->dev, kaddr, size, DMA_FROM_DEVICE);
+		if (unlikely(dma_mapping_error(nss_ctx->dev, dma_addr))) {
+			nss_info_always("%px: failed to map DDR block\n", nss_ctx);
+			kfree(kaddr);
+			return NULL;
+		}
+		dma->desc_ring = dma_addr;
 		NSS_CORE_DSB();
 	}
 	ctrl->consumer[0].ring.kp = kaddr;
--- a/nss_project.c
+++ b/nss_project.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, 2020-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -21,6 +21,9 @@
 #include "nss_tx_rx_common.h"
 
 static int nss_project_wt_stats_enable;
+static uint8_t nss_project_pri_mq_map[NSS_PROJECT_PRI_MQ_MAP_MAX_SIZE] = {0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
+module_param_array(nss_project_pri_mq_map, byte, NULL, 0);
+MODULE_PARM_DESC(nss_project_pri_mq_map, "Priority to multi-queue mapping");
 
 /*
  * nss_project_free_wt_stats()
@@ -264,6 +267,57 @@ static int nss_project_wt_stats_handler(
 }
 
 /*
+ * nss_project_pri_mq_map_send_cfg()
+ *	Sends message to firmware to configure priority to multi-queue mapping.
+ */
+static nss_tx_status_t nss_project_pri_mq_map_send_cfg(struct nss_ctx_instance *nss_ctx)
+{
+	struct nss_project_msg *npm;
+	struct nss_cmn_msg *ncm;
+	nss_tx_status_t ret;
+
+	npm = kzalloc(sizeof(*npm), GFP_ATOMIC);
+	if (!npm) {
+		nss_warning("%px: Failed to allocate buffer for message\n", nss_ctx);
+		return NSS_TX_FAILURE;
+	}
+
+	/*
+	 * Populate the message
+	 */
+	ncm = &npm->cm;
+	nss_cmn_msg_init(ncm, NSS_PROJECT_INTERFACE,
+		NSS_PROJECT_MSG_SET_QUEUE_PRI_MAP_CFG,
+		sizeof(struct nss_project_msg_pri_mq_map_cfg),
+		NULL, NULL);
+	memcpy(npm->msg.pri_mq_map_cfg.pri_mq_map, nss_project_pri_mq_map,
+		sizeof(nss_project_pri_mq_map));
+	ret = nss_core_send_cmd(nss_ctx, npm, sizeof(*npm), NSS_NBUF_PAYLOAD_SIZE);
+	kfree(npm);
+	return ret;
+}
+
+/*
+ * nss_project_pri_mq_map_configure()
+ * 	API to configure priority to multi-queue mapping.
+ */
+nss_tx_status_t nss_project_pri_mq_map_configure(struct nss_ctx_instance *nss_ctx)
+{
+	/*
+	 * Check if multi-queue configuration is enabled.
+	 */
+	if (!nss_core_is_mq_enabled()) {
+		nss_warning("%px: Multi-queue is disabled. Please enable multi-queue before configuring mapping\n", nss_ctx);
+		return NSS_TX_FAILURE_NOT_SUPPORTED;
+	}
+
+	/*
+	 * Send configuration message to NSS.
+	 */
+	return nss_project_pri_mq_map_send_cfg(nss_ctx);
+}
+
+/*
  * Tree of ctl_tables used to put the wt_stats proc node in the correct place in
  * the file system. Allows the command $ echo 1 > proc/sys/dev/nss/project/wt_stats
  * to enable worker thread statistics (echoing 0 into the same target will disable).
--- a/nss_pvxlan.c
+++ b/nss_pvxlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -80,22 +80,22 @@ static bool nss_pvxlan_hdl_instance_free
 {
 	struct nss_pvxlan_handle *h;
 
-	spin_lock(&nss_pvxlan_spinlock);
+	spin_lock_bh(&nss_pvxlan_spinlock);
 	h = nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START];
 	if (!h) {
-		spin_unlock(&nss_pvxlan_spinlock);
+		spin_unlock_bh(&nss_pvxlan_spinlock);
 		nss_warning("%px: Instance does not exist: %d", nss_ctx, if_num);
 		return false;
 	}
 
 	if (h->if_num != if_num) {
-		spin_unlock(&nss_pvxlan_spinlock);
+		spin_unlock_bh(&nss_pvxlan_spinlock);
 		nss_warning("%px: Not correct if_num: %d", nss_ctx, if_num);
 		return false;
 	}
 
 	nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] = NULL;
-	spin_unlock(&nss_pvxlan_spinlock);
+	spin_unlock_bh(&nss_pvxlan_spinlock);
 	kfree(h);
 	return true;
 }
@@ -119,9 +119,9 @@ static bool nss_pvxlan_hdl_instance_allo
 	}
 	h->if_num = if_num;
 
-	spin_lock(&nss_pvxlan_spinlock);
+	spin_lock_bh(&nss_pvxlan_spinlock);
 	if (nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
-		spin_unlock(&nss_pvxlan_spinlock);
+		spin_unlock_bh(&nss_pvxlan_spinlock);
 		kfree(h);
 		nss_warning("%px: The handle has been taken by another thread :%d", nss_ctx, if_num);
 		return false;
@@ -130,7 +130,7 @@ static bool nss_pvxlan_hdl_instance_allo
 	h->msg_callback = notify_cb;
 	h->app_data = app_data;
 	nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] = h;
-	spin_unlock(&nss_pvxlan_spinlock);
+	spin_unlock_bh(&nss_pvxlan_spinlock);
 
 	return true;
 }
@@ -201,13 +201,13 @@ static void nss_pvxlan_msg_handler(struc
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		uint32_t if_num = ncm->interface - NSS_DYNAMIC_IF_START;
-		spin_lock(&nss_pvxlan_spinlock);
+		spin_lock_bh(&nss_pvxlan_spinlock);
 		h = nss_pvxlan_hdl[if_num];
 		if (h) {
 			ncm->cb = (nss_ptr_t)h->msg_callback;
 			ncm->app_data = (nss_ptr_t)h->app_data;
 		}
-		spin_unlock(&nss_pvxlan_spinlock);
+		spin_unlock_bh(&nss_pvxlan_spinlock);
 
 	}
 
--- a/nss_qrfs.c
+++ b/nss_qrfs.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2021 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -415,6 +415,65 @@ nss_tx_status_t nss_qrfs_set_flow_rule(s
 EXPORT_SYMBOL(nss_qrfs_set_flow_rule);
 
 /*
+ * nss_qrfs_configure_flow_rule()
+ *	Configures a QRFS flow rule to NSS firmware
+ */
+nss_tx_status_t nss_qrfs_configure_flow_rule(uint32_t *dst_addr, uint32_t *src_addr, uint16_t dst_port, uint16_t src_port, uint32_t version, uint16_t proto, uint16_t cpu, enum nss_qrfs_msg_types type) {
+
+        struct nss_qrfs_msg nqm;
+        struct nss_qrfs_flow_rule_msg *nqfrm;
+        nss_tx_status_t status;
+        struct nss_ctx_instance *nss_ctx = NULL;
+	nss_qrfs_msg_callback_t cb = NULL;
+        int i;
+
+
+	memset(&nqm, 0, sizeof(struct nss_qrfs_msg));
+	nss_qrfs_msg_init(&nqm, NSS_QRFS_INTERFACE, type,
+			sizeof(struct nss_qrfs_flow_rule_msg), cb, (void *)nss_ctx);
+	if (type == NSS_QRFS_MSG_FLOW_ADD) {
+                nqfrm = &nqm.msg.flow_add;
+		cb = nss_qrfs_flow_add_msg_callback;
+	} else if (type == NSS_QRFS_MSG_FLOW_DELETE) {
+                nqfrm = &nqm.msg.flow_delete;
+		cb = nss_qrfs_flow_delete_msg_callback;
+	} else {
+		nss_warning("QRFS configure rule failed, not supported message type.\n");
+		return NSS_TX_FAILURE_BAD_PARAM;
+	}
+
+
+	nqfrm->protocol = proto;
+	nqfrm->ip_version = version;
+
+	if (version == 4) {
+		nqfrm->src_addr[0] = src_addr[0];
+		nqfrm->dst_addr[0] = dst_addr[0];
+	} else {
+		memcpy(nqfrm->src_addr, src_addr, sizeof(uint32_t) * 4);
+		memcpy(nqfrm->dst_addr, dst_addr, sizeof(uint32_t) * 4);
+	}
+
+	nqfrm->src_port = src_port;
+        nqfrm->dst_port = dst_port;
+        nqfrm->cpu = cpu;
+	nqfrm->if_num = 0;
+
+        for(i = 0; i < NSS_CORE_MAX; i++) {
+                nss_ctx = nss_qrfs_get_ctx(i);
+                status = nss_qrfs_tx_msg(nss_ctx, &nqm);
+
+		if (status) {
+			nss_warning("%px: QRFS configure rule failed, error code: %d\n", nss_ctx, status);
+			return NSS_TX_FAILURE;
+		}
+        }
+
+	return NSS_TX_SUCCESS;
+}
+EXPORT_SYMBOL(nss_qrfs_configure_flow_rule);
+
+/*
  * nss_qrfs_register_handler()
  */
 void nss_qrfs_register_handler(struct nss_ctx_instance *nss_ctx)
--- a/nss_rmnet_rx.c
+++ b/nss_rmnet_rx.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -243,6 +243,8 @@ static int nss_rmnet_rx_handle_destroy_s
 	rmnet_rx_handle[index_h2n] = NULL;
 	spin_unlock_bh(&nss_rmnet_rx_lock);
 
+	kfree(handle->stats_h2n);
+	kfree(handle->stats_n2h);
 	kfree(handle->pvt);
 	kfree(handle);
 
--- a/nss_rps.c
+++ b/nss_rps.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2017, 2019-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2017, 2019-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -278,6 +281,7 @@ static nss_tx_status_t nss_rps_cfg(struc
 	return NSS_SUCCESS;
 }
 
+#ifdef NSS_DRV_IPV4_ENABLE
 /*
  * nss_rps_ipv4_hash_bitmap_cfg()
  *	Send Message to NSS to configure hash_bitmap.
@@ -306,7 +310,9 @@ static nss_tx_status_t nss_rps_ipv4_hash
 	up(&nss_rps_cfg_pvt.sem);
 	return NSS_SUCCESS;
 }
+#endif
 
+#ifdef NSS_DRV_IPV6_ENABLE
 /*
  * nss_rps_ipv6_hash_bitmap_cfg()
  *	Send Message to NSS to configure hash_bitmap.
@@ -335,6 +341,7 @@ static nss_tx_status_t nss_rps_ipv6_hash
 	up(&nss_rps_cfg_pvt.sem);
 	return NSS_SUCCESS;
 }
+#endif
 
 /*
  * nss_rps_pri_map_cfg()
@@ -454,8 +461,8 @@ static int nss_rps_hash_bitmap_cfg_handl
 				void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	struct nss_top_instance *nss_top = &nss_top_main;
-	struct nss_ctx_instance *nss_ctx = &nss_top->nss[0];
-	int ret, ret_ipv4, ret_ipv6, current_state;
+	struct nss_ctx_instance *nss_ctx __attribute__((unused)) = &nss_top->nss[0];
+	int ret, current_state;
 
 	current_state = nss_rps_hash_bitmap;
 	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
@@ -469,32 +476,45 @@ static int nss_rps_hash_bitmap_cfg_handl
 		return ret;
 	}
 
+#if !defined(NSS_DRV_IPV4_ENABLE) || !defined(NSS_DRV_IPV6_ENABLE)
+	nss_info_always("%px: Feature is not supported\n", nss_ctx);
+	return 0;
+#else
 	if (nss_rps_hash_bitmap <= (NSS_RPS_MAX_CORE_HASH_BITMAP)) {
 		nss_info("Configuring NSS RPS hash_bitmap\n");
-		ret_ipv4 = nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
-
-		if (ret_ipv4 != NSS_SUCCESS) {
-			nss_warning("%px: ipv4 hash_bitmap config message failed\n", nss_ctx);
-			nss_rps_hash_bitmap = current_state;
-			return ret_ipv4;
+#ifdef NSS_DRV_IPV4_ENABLE
+		{
+			int ret_ipv4;
+			ret_ipv4 = nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
+
+			if (ret_ipv4 != NSS_SUCCESS) {
+				nss_warning("%px: ipv4 hash_bitmap config message failed\n", nss_ctx);
+				nss_rps_hash_bitmap = current_state;
+				return ret_ipv4;
+			}
 		}
-
-		ret_ipv6 = nss_rps_ipv6_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
-
-		if (ret_ipv6 != NSS_SUCCESS) {
-			nss_warning("%px: ipv6 hash_bitmap config message failed\n", nss_ctx);
-			nss_rps_hash_bitmap = current_state;
-			if (nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap != NSS_SUCCESS)) {
-				nss_warning("%px: ipv4 and ipv6 have different hash_bitmaps.\n", nss_ctx);
+#endif
+#ifdef NSS_DRV_IPV6_ENABLE
+		{
+			int ret_ipv6;
+			ret_ipv6 = nss_rps_ipv6_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
+
+			if (ret_ipv6 != NSS_SUCCESS) {
+				nss_warning("%px: ipv6 hash_bitmap config message failed\n", nss_ctx);
+				nss_rps_hash_bitmap = current_state;
+				if (nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap != NSS_SUCCESS)) {
+					nss_warning("%px: ipv4 and ipv6 have different hash_bitmaps.\n", nss_ctx);
+				}
+				return ret_ipv6;
 			}
-			return ret_ipv6;
 		}
-
+#endif
 		return 0;
 	}
 
 	nss_info_always("Invalid input value. Valid values are less than %d\n", (NSS_RPS_MAX_CORE_HASH_BITMAP));
 	return ret;
+#endif
 }
 
 /* nss_rps_pri_map_cfg_handler()
--- a/nss_stats.c
+++ b/nss_stats.c
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -149,6 +152,14 @@ int nss_stats_open(struct inode *inode,
 }
 
 /*
+ * nss_clear_stats_write()
+ *	Clear content of stats.
+ */
+ssize_t nss_clear_stats_write(struct file *fp, const char __user *ubuf, size_t sz, loff_t *ppos) {
+	return -ESRCH;
+}
+
+/*
  * nss_stats_release()
  *	Releases stats file.
  */
@@ -389,7 +400,9 @@ void nss_stats_create_dentry(char *name,
 /*
  * gmac_stats_ops
  */
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 NSS_STATS_DECLARE_FILE_OPERATIONS(gmac);
+#endif
 
 /*
  * wt_stats_ops
@@ -444,7 +457,9 @@ void nss_stats_init(void)
 	/*
 	 * gmac_stats
 	 */
+#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_stats_create_dentry("gmac", &nss_gmac_stats_ops);
+#endif
 
 	/*
 	 * Per-project stats
--- a/nss_stats.h
+++ b/nss_stats.h
@@ -1,9 +1,12 @@
 /*
  **************************************************************************
  * Copyright (c) 2016-2017, 2019-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -38,10 +41,11 @@
 #define NSS_STATS_EXTRA_OUTPUT_LINES 35
 
 #define NSS_STATS_DECLARE_FILE_OPERATIONS(name) \
-static const struct file_operations nss_##name##_stats_ops = { \
+static struct file_operations nss_##name##_stats_ops = { \
 	.open = nss_stats_open, \
 	.read = nss_##name##_stats_read, \
-	.llseek = generic_file_llseek, \
+	.write = nss_clear_stats_write, \
+	.llseek = generic_file_llseek,		\
 	.release = nss_stats_release, \
 };
 
@@ -68,6 +72,7 @@ extern void nss_stats_register_sysctl(vo
 void nss_stats_init(void);
 extern int nss_stats_release(struct inode *inode, struct file *filp);
 extern int nss_stats_open(struct inode *inode, struct file *filp);
+extern ssize_t nss_clear_stats_write(struct file *fp, const char __user *ubuf, size_t sz, loff_t *ppos);
 void nss_stats_create_dentry(char *name, const struct file_operations *ops);
 extern void nss_stats_reset_common_stats(uint32_t if_num);
 extern size_t nss_stats_fill_common_stats(uint32_t if_num, int instance, char *lbuf, size_t size_wr, size_t size_al, char *node);
--- a/nss_tx_rx_common.h
+++ b/nss_tx_rx_common.h
@@ -92,6 +92,7 @@ extern void nss_dtls_cmn_register_handle
 extern void nss_tls_register_handler(void);
 extern void nss_gre_tunnel_register_handler(void);
 extern void nss_trustsec_tx_register_handler(void);
+extern void nss_trustsec_rx_register_handler(void);
 extern void nss_wifili_register_handler(void);
 extern void nss_ppe_register_handler(void);
 extern void nss_gre_redir_mark_register_handler(void);
--- a/nss_vxlan.c
+++ b/nss_vxlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -226,6 +226,7 @@ bool nss_vxlan_unregister_if(uint32_t if
 	}
 
 	nss_core_unregister_handler(nss_ctx, if_num);
+	nss_core_unregister_msg_handler(nss_ctx, if_num);
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 	return true;
 }
--- a/nss_wifi_vdev.c
+++ b/nss_wifi_vdev.c
@@ -199,8 +199,16 @@ EXPORT_SYMBOL(nss_wifi_vdev_tx_msg_ext);
  */
 nss_tx_status_t nss_wifi_vdev_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num)
 {
+	enum nss_dynamic_interface_type if_type;
+
 	BUG_ON(((if_num < NSS_DYNAMIC_IF_START) || (if_num >= (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES))));
 
+	if_type = nss_dynamic_interface_get_type(nss_ctx, if_num);
+	if (if_type != NSS_DYNAMIC_INTERFACE_TYPE_VAP) {
+		nss_warning("%px: non vap %d packet tx not allowed", nss_ctx, if_num);
+		return NSS_TX_FAILURE_NOT_SUPPORTED;
+	}
+
 	return nss_core_send_packet(nss_ctx, os_buf, if_num, H2N_BIT_FLAG_BUFFER_REUSABLE);
 }
 EXPORT_SYMBOL(nss_wifi_vdev_tx_buf);
--- a/exports/nss_n2h.h
+++ b/exports/nss_n2h.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -62,6 +62,7 @@ struct nss_n2h_cfg_pvt {
 	struct nss_n2h_payload_info empty_buf_pool_info;	/**< Empty buffer pool information. */
 	struct nss_n2h_payload_info empty_paged_buf_pool_info;	/**< Paged buffer pool information. */
 	int wifi_pool;						/**< Size of the empty Wi-Fi buffer pool. */
+	int shaper_pool;					/**< Size of the empty shaper pool. */
 	int response;						/**< Response from the firmware. */
 };
 
@@ -132,6 +133,7 @@ enum nss_n2h_metadata_types {
 	NSS_TX_METADATA_TYPE_N2H_QUEUE_LIMIT_CFG,
 	NSS_TX_METADATA_TYPE_N2H_PAGED_BUFFER_POOL_INIT,
 	NSS_TX_METADATA_TYPE_N2H_HOST_BACK_PRESSURE_CFG,
+	NSS_TX_METADATA_TYPE_N2H_SHAPER_POOL_CFG,
 	NSS_METADATA_TYPE_N2H_MAX,
 };
 
@@ -360,6 +362,24 @@ struct nss_n2h_host_back_pressure {
 };
 
 /**
+ * nss_n2h_shaper_mem_cfg_msg
+ *	Shaper memory configuration message.
+ */
+struct nss_n2h_shaper_mem_cfg_msg {
+	uint32_t mem_blk_size;	/**< Size of the memory block. */
+	uint32_t num_blks;		/**< Number of memory blocks. */
+
+	uint32_t pool_addr[MAX_PAGES_PER_MSG];
+			/**< Buffer addresses. */
+	nss_ptr_t pool_vaddr[MAX_PAGES_PER_MSG];
+			/**< Virtual addresses of the buffers. */
+#ifndef __LP64__
+	uint32_t padding[MAX_PAGES_PER_MSG];
+			/**< Padding that fits up to 64 bits. Do not reuse. */
+#endif
+};
+
+/**
  * nss_n2h_msg
  *	Data for sending and receiving N2H messages.
  */
@@ -406,6 +426,8 @@ struct nss_n2h_msg {
 				/**< Paged buffer pool initialization. */
 		struct nss_n2h_host_back_pressure host_bp_cfg;
 				/**< Host back pressure configuration. */
+		struct nss_n2h_shaper_mem_cfg_msg shaper_mem_cfg;
+				/**< Shaper memory configuration. */
 	} msg;			/**< Message payload. */
 };
 
