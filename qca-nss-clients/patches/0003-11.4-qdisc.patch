--- a/nss_qdisc/Makefile
+++ b/nss_qdisc/Makefile
@@ -6,7 +6,7 @@ ifeq ($(SoC),$(filter $(SoC),ipq807x ipq
 ccflags-y += -DNSS_QDISC_PPE_SUPPORT -DNSS_QDISC_BRIDGE_SUPPORT
 endif
 
-ccflags-y += -Werror
+ccflags-y += -Wall -Werror
 
 obj-m += qca-nss-qdisc.o
 qca-nss-qdisc-objs := 	nss_qdisc.o \
--- a/nss_qdisc/igs/Makefile
+++ b/nss_qdisc/igs/Makefile
@@ -2,7 +2,7 @@
 
 ccflags-y += $(NSS_CCFLAGS) -I$(obj)/../../exports
 ccflags-y += -DNSS_IGS_DEBUG_LEVEL=2
-ccflags-y += -Werror
+ccflags-y += -Wall -Werror
 
 obj-m += act_nssmirred.o
 act_nssmirred-objs := \
--- a/nss_qdisc/igs/nss_mirred.c
+++ b/nss_qdisc/igs/nss_mirred.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -24,12 +24,20 @@
 
 static LIST_HEAD(nss_mirred_list);		/* List for all nss mirred actions */
 static DEFINE_SPINLOCK(nss_mirred_list_lock);	/* Lock for the nss mirred list */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+static unsigned int nss_mirred_net_id;		/* NSS mirror net ID */
+static struct tc_action_ops nss_mirred_act_ops;	/* NSS action mirror ops */
+#endif
 
 /*
  * nss_mirred_release()
  *	Cleanup the resources for nss mirred action.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 static void nss_mirred_release(struct tc_action *tc_act, int bind)
+#else
+static void nss_mirred_release(struct tc_action *tc_act)
+#endif
 {
 	struct nss_mirred_tcf *act = nss_mirred_get(tc_act);
 	struct net_device *dev = rcu_dereference_protected(act->tcfm_dev, 1);
@@ -75,9 +83,23 @@ static const struct nla_policy nss_mirre
  *	Initialize the nss mirred action.
  */
 static int nss_mirred_init(struct net *net, struct nlattr *nla,
-			   struct nlattr *est, struct tc_action *tc_act, int ovr,
-			   int bind)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+						struct nlattr *est, struct tc_action *tc_act, int ovr,
+						int bind)
 {
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0))
+						struct nlattr *est, struct tc_action **tc_act, int ovr,
+						int bind, bool rtnl_held, struct tcf_proto *tp,
+						u32 flags, struct netlink_ext_ack *extack)
+{
+#else
+						struct nlattr *est, struct tc_action **tc_act,
+						struct tcf_proto *tp, u32 flags, struct netlink_ext_ack *extack)
+{
+	bool bind = flags & TCA_ACT_FLAGS_BIND;
+#endif
+	struct tc_action_net *tn = net_generic(net, nss_mirred_net_id);
+	u32 index;
 	struct nlattr *arr[TC_NSS_MIRRED_MAX + 1];
 	struct tc_nss_mirred *parm;
 	struct nss_mirred_tcf *act;
@@ -92,7 +114,11 @@ static int nss_mirred_init(struct net *n
 	/*
 	 * Parse and validate the user configurations.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0))
 	ret = nla_parse_nested(arr, TC_NSS_MIRRED_MAX, nla, nss_mirred_policy);
+#else
+	ret = nla_parse_nested_deprecated(arr, TC_NSS_MIRRED_MAX, nla, nss_mirred_policy, extack);
+#endif
 	if (ret < 0) {
 		return ret;
 	}
@@ -193,6 +219,7 @@ static int nss_mirred_init(struct net *n
 	/*
 	 * Return error if nss mirred action index is present in the hash.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	if (tcf_hash_check(parm->index, tc_act, bind)) {
 		return -EEXIST;
 	}
@@ -204,7 +231,33 @@ static int nss_mirred_init(struct net *n
 	}
 
 	act = nss_mirred_get(tc_act);
+#else
+	index = parm->index;
+	ret = tcf_idr_check_alloc(tn, &index, tc_act, bind);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (ret && bind) {
+		return 0;
+	}
+
+	if (!ret) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 5, 0))
+		ret = tcf_idr_create(tn, index, est, tc_act, &nss_mirred_act_ops,
+				bind, true);
+#else
+		ret = tcf_idr_create(tn, index, est, tc_act, &nss_mirred_act_ops,
+				bind, true, 0);
+#endif
+		if (ret) {
+			tcf_idr_cleanup(tn, index);
+			return ret;
+		}
+	}
 
+	act = nss_mirred_get(*tc_act);
+#endif
 	/*
 	 * Fill up the nss mirred tc parameters to
 	 * its local action structure.
@@ -222,7 +275,9 @@ static int nss_mirred_init(struct net *n
 	spin_lock_bh(&nss_mirred_list_lock);
 	list_add(&act->tcfm_list, &nss_mirred_list);
 	spin_unlock_bh(&nss_mirred_list_lock);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	tcf_hash_insert(tc_act);
+#endif
 
 	return ACT_P_CREATED;
 }
@@ -234,10 +289,15 @@ static int nss_mirred_init(struct net *n
 static int nss_mirred_act(struct sk_buff *skb, const struct tc_action *tc_act,
 		      struct tcf_result *res)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	struct nss_mirred_tcf *act = tc_act->priv;
+#else
+	struct nss_mirred_tcf *act = nss_mirred_get(tc_act);
+#endif
 	struct net_device *dev;
 	struct sk_buff *skb_new;
 	int retval, err;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	u32 skb_tc_at = G_TC_AT(skb->tc_verd);
 
 	/*
@@ -247,6 +307,12 @@ static int nss_mirred_act(struct sk_buff
 		return TC_ACT_UNSPEC;
 	}
 
+#else
+	if (!skb_at_tc_ingress(skb)) {
+		return TC_ACT_UNSPEC;
+	}
+#endif
+
 	/*
 	 * Update the last use of action.
 	 */
@@ -276,9 +342,14 @@ static int nss_mirred_act(struct sk_buff
 
 	skb_new->skb_iif = skb->dev->ifindex;
 	skb_new->dev = dev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	skb_new->tc_verd = SET_TC_FROM(skb_new->tc_verd, skb_tc_at);
 	skb_push_rcsum(skb_new, skb->mac_len);
 	skb_sender_cpu_clear(skb_new);
+#else
+	skb_set_redirected(skb_new, skb_new->tc_at_ingress);
+	skb_push_rcsum(skb_new, skb->mac_len);
+#endif
 
 	err = dev_queue_xmit(skb_new);
 	if (!err) {
@@ -300,12 +371,21 @@ static int nss_mirred_dump(struct sk_buf
 {
 	struct tcf_t filter;
 	unsigned char *tail = skb_tail_pointer(skb);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	struct nss_mirred_tcf *act = tc_act->priv;
+#else
+	struct nss_mirred_tcf *act = nss_mirred_get(tc_act);
+#endif
 	struct tc_nss_mirred opt = {
 		.index   = act->tcf_index,
 		.action  = act->tcf_action,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 		.refcnt  = act->tcf_refcnt - ref,
 		.bindcnt = act->tcf_bindcnt - bind,
+#else
+		.refcnt  = refcount_read(&act->tcf_refcnt) - ref,
+		.bindcnt = atomic_read(&act->tcf_bindcnt) - bind,
+#endif
 		.from_ifindex = act->tcfm_from_ifindex,
 		.to_ifindex = act->tcfm_to_ifindex,
 	};
@@ -470,6 +550,64 @@ static int nss_mirred_device_event(struc
 	return NOTIFY_DONE;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+/*
+ * nss_mirred_walker
+ *	nssmirred tcf_action walker
+ */
+static int nss_mirred_walker(struct net *net, struct sk_buff *skb,
+		struct netlink_callback *cb, int type,
+		const struct tc_action_ops *ops,
+		struct netlink_ext_ack *extack)
+{
+	struct tc_action_net *tn = net_generic(net, nss_mirred_net_id);
+
+	return tcf_generic_walker(tn, skb, cb, type, ops, extack);
+}
+
+/*
+ * nss_mirred_search
+ *	nssmirred search idr function.
+ */
+static int nss_mirred_search(struct net *net, struct tc_action **a, u32 index)
+{
+	struct tc_action_net *tn = net_generic(net, nss_mirred_net_id);
+
+	return tcf_idr_search(tn, a, index);
+}
+
+/*
+ * nss_mirred_dev_put
+ *	Release igs dev
+ */
+static void nss_mirred_dev_put(void *priv)
+{
+	struct net_device *dev = priv;
+
+	dev_put(dev);
+}
+
+/*
+ * nss_mirred_device
+ *	Get the igs dev.
+ */
+static struct net_device *nss_mirred_device(const struct tc_action *a, tc_action_priv_destructor *destructor)
+{
+	struct nss_mirred_tcf *m = nss_mirred_get(a);
+	struct net_device *dev;
+
+	rcu_read_lock();
+	dev = rcu_dereference(m->tcfm_dev);
+	if (dev) {
+		dev_hold(dev);
+		*destructor = nss_mirred_dev_put;
+	}
+	rcu_read_unlock();
+
+	return dev;
+}
+#endif
+
 /*
  * nss_mirred_device_notifier
  *	nss mirred device notifier structure.
@@ -482,14 +620,22 @@ static struct notifier_block nss_mirred_
  * nss_mirred_act_ops
  *	Registration structure for nss mirred action.
  */
-struct tc_action_ops nss_mirred_act_ops = {
+static struct tc_action_ops nss_mirred_act_ops = {
 	.kind		=	"nssmirred",
-	.type		=	TCA_ACT_MIRRED_NSS,
 	.owner		=	THIS_MODULE,
 	.act		=	nss_mirred_act,
 	.dump		=	nss_mirred_dump,
 	.cleanup	=	nss_mirred_release,
 	.init		=	nss_mirred_init,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+	.type		=	TCA_ACT_MIRRED_NSS,
+#else
+	.id		=	TCA_ID_MIRRED_NSS,
+	.walk		=	nss_mirred_walker,
+	.lookup		=	nss_mirred_search,
+	.size           =       sizeof(struct nss_mirred_tcf),
+	.get_dev	=	nss_mirred_device
+#endif
 };
 
 /*
@@ -514,6 +660,52 @@ struct nf_hook_ops nss_mirred_igs_nf_ops
 	},
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+/*
+ * nss_mirred_init_net
+ *	nssmirred net init function.
+ */
+static __net_init int nss_mirred_init_net(struct net *net)
+{
+	struct tc_action_net *tn = net_generic(net, nss_mirred_net_id);
+	nf_register_net_hooks(net, nss_mirred_igs_nf_ops,
+			ARRAY_SIZE(nss_mirred_igs_nf_ops));
+
+	return tc_action_net_init(net, tn, &nss_mirred_act_ops);
+}
+
+/*
+ * nss_mirred_exit_net
+ *	nssmirred net exit function.
+ */
+static void __net_exit nss_mirred_exit_net(struct net *net)
+{
+	nf_unregister_net_hooks(net, nss_mirred_igs_nf_ops,
+			ARRAY_SIZE(nss_mirred_igs_nf_ops));
+}
+
+/*
+ * nss_mirred_exit_batch_net
+ *	nssmirred exit_batch_net function.
+ */
+static void __net_exit nss_mirred_exit_batch_net(struct list_head *net_list)
+{
+	tc_action_net_exit(net_list, nss_mirred_net_id);
+}
+
+/*
+ * nss_mirred_net_ops
+ *	Per netdevice ops.
+ */
+static struct pernet_operations nss_mirred_net_ops = {
+	.init = nss_mirred_init_net,
+	.exit = nss_mirred_exit_net,
+	.exit_batch = nss_mirred_exit_batch_net,
+	.id   = &nss_mirred_net_id,
+	.size = sizeof(struct tc_action_net),
+};
+#endif
+
 /*
  * nss_mirred_init_module()
  *	nssmirred init function.
@@ -525,6 +717,7 @@ static int __init nss_mirred_init_module
 		return err;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	err = tcf_register_action(&nss_mirred_act_ops, NSS_MIRRED_TAB_MASK);
 	if (err) {
 		unregister_netdevice_notifier(&nss_mirred_device_notifier);
@@ -538,6 +731,18 @@ static int __init nss_mirred_init_module
 		unregister_netdevice_notifier(&nss_mirred_device_notifier);
 		return err;
 	}
+#else
+	err = tcf_register_action(&nss_mirred_act_ops, &nss_mirred_net_ops);
+	if (err) {
+		unregister_netdevice_notifier(&nss_mirred_device_notifier);
+		return err;
+	}
+#endif
+
+	/*
+	 * Set the IGS module reference variable.
+	 */
+	nss_igs_module_save(&nss_mirred_act_ops, THIS_MODULE);
 
 	nss_ifb_init();
 	return 0;
@@ -549,12 +754,21 @@ static int __init nss_mirred_init_module
  */
 static void __exit nss_mirred_cleanup_module(void)
 {
+	/*
+	 * Reset the IGS module reference variable.
+	 */
+	nss_igs_module_save(&nss_mirred_act_ops, NULL);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	nf_unregister_hooks(nss_mirred_igs_nf_ops, ARRAY_SIZE(nss_mirred_igs_nf_ops));
 
 	/*
 	 * Un-register nss mirred action.
 	 */
 	tcf_unregister_action(&nss_mirred_act_ops);
+#else
+	tcf_unregister_action(&nss_mirred_act_ops, &nss_mirred_net_ops);
+#endif
 	unregister_netdevice_notifier(&nss_mirred_device_notifier);
 }
 
--- a/nss_qdisc/igs/nss_mirred.h
+++ b/nss_qdisc/igs/nss_mirred.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -14,6 +14,7 @@
  **************************************************************************
  */
 
+#include <linux/version.h>
 #include <net/act_api.h>
 
 #define NSS_MIRRED_TAB_MASK 7
@@ -23,7 +24,11 @@
  *	nss mirred internal structure.
  */
 struct nss_mirred_tcf {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	struct tcf_common common;		/* Common filter structure */
+#else
+	struct tc_action common;		/* Common filter structure */
+#endif
 	__u32 tcfm_to_ifindex;			/* Index number of device to which
 						 * traffic will be redirected.
 						 */
@@ -40,5 +45,10 @@ struct nss_mirred_tcf {
  * To get the pointer of nss mirred action structure from the common
  * tc_action structure pointer.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 #define nss_mirred_get(a) \
 	container_of(a->priv, struct nss_mirred_tcf, common)
+#else
+#define nss_mirred_get(a) ((struct nss_mirred_tcf *)a)
+#endif
+
--- a/nss_qdisc/nss_bf.c
+++ b/nss_qdisc/nss_bf.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -58,7 +58,7 @@ static inline struct nss_bf_class_data *
 	struct Qdisc_class_common *clc;
 	clc = qdisc_class_find(&q->clhash, classid);
 	if (clc == NULL) {
-		nss_qdisc_info("Cannot find class with classid %u in qdisc %p hash table %p\n", classid, sch, &q->clhash);
+		nss_qdisc_info("Cannot find class with classid %u in qdisc %px hash table %px\n", classid, sch, &q->clhash);
 		return NULL;
 	}
 	return container_of(clc, struct nss_bf_class_data, cl_common);
@@ -68,12 +68,20 @@ static inline struct nss_bf_class_data *
  * nss_bf_change_class()
  *	Configures a new class.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_bf_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 		  struct nlattr **tca, unsigned long *arg)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_bf_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
+		  struct nlattr **tca, unsigned long *arg, struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_bf_sched_data *q = qdisc_priv(sch);
 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)*arg;
 	struct nlattr *opt = tca[TCA_OPTIONS];
+	struct nlattr *tb[TCA_NSSBF_MAX + 1];
 	struct tc_nssbf_class_qopt *qopt;
 	struct nss_if_msg nim_config;
 	struct net_device *dev = qdisc_dev(sch);
@@ -84,7 +92,12 @@ static int nss_bf_change_class(struct Qd
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, TCA_NSSBF_MAX, TCA_NSSBF_CLASS_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, tb, TCA_NSSBF_MAX, TCA_NSSBF_CLASS_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, tb, TCA_NSSBF_MAX, TCA_NSSBF_CLASS_PARMS, extack);
+#endif
+
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -102,7 +115,7 @@ static int nss_bf_change_class(struct Qd
 			return -EINVAL;
 		}
 
-		nss_qdisc_info("Bf class %u allocated %p\n", classid, cl);
+		nss_qdisc_info("Bf class %u allocated %px\n", classid, cl);
 		cl->cl_common.classid = classid;
 
 		/*
@@ -111,17 +124,18 @@ static int nss_bf_change_class(struct Qd
 		 * reference count should not be 0.
 		 */
 		cl->qdisc = &noop_qdisc;
-		atomic_set(&cl->nq.refcnt, 1);
+		nss_qdisc_atomic_set(&cl->nq);
 		*arg = (unsigned long)cl;
 
-		nss_qdisc_info("Adding classid %u to qdisc %p hash queue %p\n", classid, sch, &q->clhash);
+		nss_qdisc_info("Adding classid %u to qdisc %px hash queue %px\n", classid, sch, &q->clhash);
 
 		/*
 		 * This is where a class gets initialized. Classes do not have a init function
 		 * that is registered to Linux. Therefore we initialize the NSSBF_GROUP shaper
 		 * here.
 		 */
-		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_BF_GROUP, classid, accel_mode) < 0) {
+		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_BF_GROUP, classid, accel_mode, extack) < 0)
+		{
 			nss_qdisc_error("Nss init for class %u failed\n", classid);
 			kfree(cl);
 			return -EINVAL;
@@ -229,7 +243,7 @@ static void nss_bf_destroy_class(struct
 	struct nss_bf_sched_data *q = qdisc_priv(sch);
 	struct nss_if_msg nim;
 
-	nss_qdisc_info("Destroying bf class %p from qdisc %p\n", cl, sch);
+	nss_qdisc_info("Destroying bf class %px from qdisc %px\n", cl, sch);
 
 	/*
 	 * Note, this function gets called even for NSSBF and not just for NSSBF_GROUP.
@@ -238,8 +252,8 @@ static void nss_bf_destroy_class(struct
 	 * only for the root qdisc.
 	 */
 	if (cl == &q->root) {
-		nss_qdisc_info("We do not destroy bf class %p here since this is "
-				"the qdisc %p\n", cl, sch);
+		nss_qdisc_info("We do not destroy bf class %px here since this is "
+				"the qdisc %px\n", cl, sch);
 		return;
 	}
 
@@ -260,7 +274,7 @@ static void nss_bf_destroy_class(struct
 	/*
 	 * And now we destroy the child.
 	 */
-	qdisc_destroy(cl->qdisc);
+	 nss_qdisc_put(cl->qdisc);
 
 	/*
 	 * Stop the stats polling timer and free class
@@ -282,7 +296,11 @@ static void nss_bf_destroy_class(struct
  * nss_bf_delete_class()
  *	Detaches a class from operation, but does not destroy it.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+static int nss_bf_delete_class(struct Qdisc *sch, unsigned long arg, struct netlink_ext_ack *extack)
+#else
 static int nss_bf_delete_class(struct Qdisc *sch, unsigned long arg)
+#endif
 {
 	struct nss_bf_sched_data *q = qdisc_priv(sch);
 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)arg;
@@ -300,7 +318,7 @@ static int nss_bf_delete_class(struct Qd
 	/*
 	 * The message to NSS should be sent to the parent of this class
 	 */
-	nss_qdisc_info("Detaching bf class: %p\n", cl);
+	nss_qdisc_info("Detaching bf class: %px\n", cl);
 	nim.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = q->nq.qos_tag;
 	nim.msg.shaper_configure.config.msg.shaper_node_config.snc.bf_detach.child_qos_tag = cl->nq.qos_tag;
 	if (nss_qdisc_node_detach(&q->nq, nq_child, &nim,
@@ -311,10 +329,10 @@ static int nss_bf_delete_class(struct Qd
 	sch_tree_lock(sch);
 	qdisc_reset(cl->qdisc);
 	qdisc_class_hash_remove(&q->clhash, &cl->cl_common);
-	refcnt = atomic_sub_return(1, &cl->nq.refcnt);
+	refcnt = nss_qdisc_atomic_sub_return(&cl->nq);
 	sch_tree_unlock(sch);
 	if (!refcnt) {
-		nss_qdisc_error("Reference count should not be zero for class %p\n", cl);
+		nss_qdisc_error("Reference count should not be zero for class %px\n", cl);
 	}
 
 	return 0;
@@ -324,8 +342,13 @@ static int nss_bf_delete_class(struct Qd
  * nss_bf_graft_class()
  *	Replaces the qdisc attached to the provided class.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_bf_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
 								 struct Qdisc **old)
+#else
+static int nss_bf_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
+								 struct Qdisc **old, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_bf_sched_data *q = qdisc_priv(sch);
 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)arg;
@@ -333,10 +356,10 @@ static int nss_bf_graft_class(struct Qdi
 	struct nss_if_msg nim_attach;
 	struct nss_qdisc *nq_new = qdisc_priv(new);
 
-	nss_qdisc_info("Grafting class %p\n", sch);
+	nss_qdisc_info("Grafting class %px\n", sch);
 
 	if (cl == &q->root) {
-		nss_qdisc_error("Can't graft root class %p\n", cl);
+		nss_qdisc_error("Can't graft root class %px\n", cl);
 		return -EINVAL;
 	}
 
@@ -351,10 +374,10 @@ static int nss_bf_graft_class(struct Qdi
 	 * Since we initially attached a noop qdisc as child (in Linux),
 	 * we do not perform a detach in the NSS if its a noop qdisc.
 	 */
-	nss_qdisc_info("Grafting old: %p with new: %p\n", *old, new);
+	nss_qdisc_info("Grafting old: %px with new: %px\n", *old, new);
 	if (*old != &noop_qdisc) {
 		struct nss_qdisc *nq_old = (struct nss_qdisc *)qdisc_priv(*old);
-		nss_qdisc_info("Detaching old: %p\n", *old);
+		nss_qdisc_info("Detaching old: %px\n", *old);
 		nim_detach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = cl->nq.qos_tag;
 		if (nss_qdisc_node_detach(&cl->nq, nq_old, &nim_detach,
 				NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_DETACH) < 0) {
@@ -367,7 +390,7 @@ static int nss_bf_graft_class(struct Qdi
 	 * to the NSS.
 	 */
 	if (new != &noop_qdisc) {
-		nss_qdisc_info("Attaching new: %p\n", new);
+		nss_qdisc_info("Attaching new: %px\n", new);
 		nim_attach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = cl->nq.qos_tag;
 		nim_attach.msg.shaper_configure.config.msg.shaper_node_config.snc.bf_group_attach.child_qos_tag = nq_new->qos_tag;
 		if (nss_qdisc_node_attach(&cl->nq, nq_new, &nim_attach,
@@ -393,7 +416,7 @@ static int nss_bf_graft_class(struct Qdi
 static struct Qdisc *nss_bf_leaf_class(struct Qdisc *sch, unsigned long arg)
 {
 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)arg;
-	nss_qdisc_info("bf class leaf %p\n", cl);
+	nss_qdisc_info("bf class leaf %px\n", cl);
 
 	/*
 	 * Since all nss_bf groups are leaf nodes, we can always
@@ -408,13 +431,14 @@ static struct Qdisc *nss_bf_leaf_class(s
  */
 static void nss_bf_qlen_notify(struct Qdisc *sch, unsigned long arg)
 {
-	nss_qdisc_info("bf qlen notify %p\n", sch);
+	nss_qdisc_info("bf qlen notify %px\n", sch);
 	/*
 	 * Gets called when qlen of child changes (Useful for deactivating)
 	 * Not useful for us here.
 	 */
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 /*
  * nss_bf_get_class()
  *	Fetches the class pointer if provided the classid.
@@ -423,7 +447,7 @@ static unsigned long nss_bf_get_class(st
 {
 	struct nss_bf_class_data *cl = nss_bf_find_class(classid, sch);
 
-	nss_qdisc_info("Get bf class %p - class match = %p\n", sch, cl);
+	nss_qdisc_info("Get bf class %px - class match = %px\n", sch, cl);
 
 	if (cl != NULL)
 		atomic_add(1, &cl->nq.refcnt);
@@ -438,16 +462,30 @@ static unsigned long nss_bf_get_class(st
 static void nss_bf_put_class(struct Qdisc *sch, unsigned long arg)
 {
 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)arg;
-	nss_qdisc_info("bf put class for %p\n", cl);
+	nss_qdisc_info("bf put class for %px\n", cl);
 
 	/*
 	 * We are safe to destroy the qdisc if the reference count
 	 * goes down to 0.
 	 */
-	if (atomic_sub_return(1, &cl->nq.refcnt) == 0) {
+	if (nss_qdisc_atomic_sub_return(&cl->nq) == 0) {
 		nss_bf_destroy_class(sch, cl);
 	}
 }
+#else
+/*
+ * nss_bf_search_class()
+ *	Fetches the class pointer if provided the classid.
+ */
+static unsigned long nss_bf_search_class(struct Qdisc *sch, u32 classid)
+{
+	struct nss_bf_class_data *cl = nss_bf_find_class(classid, sch);
+
+	nss_qdisc_info("Get bf class %px - class match = %px\n", sch, cl);
+
+	return (unsigned long)cl;
+}
+#endif
 
 /*
  * nss_bf_dump_class()
@@ -460,7 +498,7 @@ static int nss_bf_dump_class(struct Qdis
 	struct nlattr *opts;
 	struct tc_nssbf_class_qopt qopt;
 
-	nss_qdisc_info("Dumping class %p of Qdisc %p\n", cl, sch);
+	nss_qdisc_info("Dumping class %px of Qdisc %px\n", cl, sch);
 
 	qopt.burst = cl->burst;
 	qopt.rate = cl->rate;
@@ -475,7 +513,7 @@ static int nss_bf_dump_class(struct Qdis
 	tcm->tcm_handle = cl->cl_common.classid;
 	tcm->tcm_info = cl->qdisc->handle;
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL || nla_put(skb, TCA_NSSBF_CLASS_PARMS, sizeof(qopt), &qopt)) {
 		goto nla_put_failure;
 	}
@@ -495,7 +533,7 @@ static int nss_bf_dump_class_stats(struc
 {
 	struct nss_qdisc *nq = (struct nss_qdisc *)arg;
 
-	if (nss_qdisc_gnet_stats_copy_basic(d, &nq->bstats) < 0 ||
+	if (nss_qdisc_gnet_stats_copy_basic(sch, d, &nq->bstats) < 0 ||
 			nss_qdisc_gnet_stats_copy_queue(d, &nq->qstats) < 0) {
 		return -1;
 	}
@@ -514,7 +552,7 @@ static void nss_bf_walk(struct Qdisc *sc
 	struct nss_bf_class_data *cl;
 	unsigned int i;
 
-	nss_qdisc_info("In bf walk %p\n", sch);
+	nss_qdisc_info("In bf walk %px\n", sch);
 	if (arg->stop)
 		return;
 
@@ -538,9 +576,15 @@ static void nss_bf_walk(struct Qdisc *sc
  * nss_bf_change_qdisc()
  *	Can be used to configure a nssbf qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_bf_change_qdisc(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_bf_change_qdisc(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_bf_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSBF_MAX + 1];
 	struct tc_nssbf_qopt *qopt;
 
 	/*
@@ -563,7 +607,11 @@ static int nss_bf_change_qdisc(struct Qd
 	/*
 	 * If it is not NULL, parse to get qopt.
 	 */
-	qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, TCA_NSSBF_MAX, TCA_NSSBF_QDISC_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, tb, TCA_NSSBF_MAX, TCA_NSSBF_QDISC_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, tb, TCA_NSSBF_MAX, TCA_NSSBF_QDISC_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -587,7 +635,7 @@ static int nss_bf_change_qdisc(struct Qd
 static void nss_bf_reset_class(struct nss_bf_class_data *cl)
 {
 	nss_qdisc_reset(cl->qdisc);
-	nss_qdisc_info("Nssbf class resetted %p\n", cl->qdisc);
+	nss_qdisc_info("Nssbf class resetted %px\n", cl->qdisc);
 }
 
 /*
@@ -607,7 +655,7 @@ static void nss_bf_reset_qdisc(struct Qd
 	}
 
 	nss_qdisc_reset(sch);
-	nss_qdisc_info("Nssbf qdisc resetted %p\n", sch);
+	nss_qdisc_info("Nssbf qdisc resetted %px\n", sch);
 }
 
 /*
@@ -634,8 +682,8 @@ static void nss_bf_destroy_qdisc(struct
 			 * care of by the nss_bf_destroy() function.
 			 */
 			if (cl == &q->root) {
-				nss_qdisc_info("We do not detach or destroy bf class %p here since this is "
-						"the qdisc %p\n", cl, sch);
+				nss_qdisc_info("We do not detach or destroy bf class %px here since this is "
+						"the qdisc %px\n", cl, sch);
 				continue;
 			}
 
@@ -643,7 +691,7 @@ static void nss_bf_destroy_qdisc(struct
 			 * Reduce refcnt by 1 before destroying. This is to
 			 * ensure that polling of stat stops properly.
 			 */
-			atomic_sub(1, &cl->nq.refcnt);
+			 nss_qdisc_atomic_sub(&cl->nq);
 
 			/*
 			 * Detach class before destroying it. We dont check for noop qdisc here
@@ -677,21 +725,29 @@ static void nss_bf_destroy_qdisc(struct
 	 *	 will be taken care of by the graft call.
 	 */
 	nss_qdisc_destroy(&q->nq);
-	nss_qdisc_info("Nssbf destroyed %p\n", sch);
+	nss_qdisc_info("Nssbf destroyed %px\n", sch);
 }
 
 /*
  * nss_bf_init_qdisc()
  *	Initializes the nssbf qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_bf_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_bf_init_qdisc(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_bf_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSBF_MAX + 1];
 	struct tc_nssbf_qopt *qopt;
 	int err;
 	unsigned int accel_mode;
 
-	nss_qdisc_info("Init bf qdisc %p\n", sch);
+	nss_qdisc_info("Init bf qdisc %px\n", sch);
 
 	err = qdisc_class_hash_init(&q->clhash);
 	if (err < 0) {
@@ -710,7 +766,11 @@ static int nss_bf_init_qdisc(struct Qdis
 	if (!opt) {
 		accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
 	} else {
-		qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, TCA_NSSBF_MAX, TCA_NSSBF_QDISC_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+		qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, tb, TCA_NSSBF_MAX, TCA_NSSBF_QDISC_PARMS);
+#else
+		qopt = nss_qdisc_qopt_get(opt, nss_bf_policy, tb, TCA_NSSBF_MAX, TCA_NSSBF_QDISC_PARMS, extack);
+#endif
 		if (!qopt) {
 			return -EINVAL;
 		}
@@ -720,7 +780,7 @@ static int nss_bf_init_qdisc(struct Qdis
 	/*
 	 * Initialize the NSSBF shaper in NSS
 	 */
-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_BF, 0, accel_mode) < 0) {
+	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_BF, 0, accel_mode, extack) < 0) {
 		return -EINVAL;
 	}
 
@@ -729,7 +789,11 @@ static int nss_bf_init_qdisc(struct Qdis
 	/*
 	 * Tune nss_bf parameters.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_bf_change_qdisc(sch, opt) < 0) {
+#else
+	if (nss_bf_change_qdisc(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(&q->nq);
 		return -EINVAL;
 	}
@@ -756,7 +820,7 @@ static int nss_bf_dump_qdisc(struct Qdis
 	qopt.defcls = q->defcls;
 	qopt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (!opts || nla_put(skb, TCA_NSSBF_QDISC_PARMS, sizeof(qopt), &qopt)) {
 		goto nla_put_failure;
 	}
@@ -772,9 +836,18 @@ nla_put_failure:
  * nss_bf_enqueue()
  *	Enqueues a skb to nssbf qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_bf_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_bf_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 /*
@@ -786,6 +859,7 @@ static struct sk_buff *nss_bf_dequeue(st
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_bf_drop()
  *	Drops a single skb from linux queue, if not empty.
@@ -797,6 +871,7 @@ static unsigned int nss_bf_drop(struct Q
 	printk("In bf drop\n");
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 /*
  * Registration structure for nssbf class
@@ -807,9 +882,17 @@ const struct Qdisc_class_ops nss_bf_clas
 	.graft		= nss_bf_graft_class,
 	.leaf		= nss_bf_leaf_class,
 	.qlen_notify	= nss_bf_qlen_notify,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	.get		= nss_bf_get_class,
 	.put		= nss_bf_put_class,
+#else
+	.find		= nss_bf_search_class,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	.tcf_chain	= nss_qdisc_tcf_chain,
+#else
+	.tcf_block      = nss_qdisc_tcf_block,
+#endif
 	.bind_tcf	= nss_qdisc_tcf_bind,
 	.unbind_tcf	= nss_qdisc_tcf_unbind,
 	.dump		= nss_bf_dump_class,
@@ -830,7 +913,9 @@ struct Qdisc_ops nss_bf_qdisc_ops __read
 	.enqueue	= nss_bf_enqueue,
 	.dequeue	= nss_bf_dequeue,
 	.peek		= qdisc_peek_dequeued,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		= nss_bf_drop,
+#endif
 	.cl_ops		= &nss_bf_class_ops,
 	.priv_size	= sizeof(struct nss_bf_sched_data),
 	.owner		= THIS_MODULE
--- a/nss_qdisc/nss_blackhole.c
+++ b/nss_qdisc/nss_blackhole.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2016-2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017, 2020,  The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -35,9 +35,18 @@ static struct nla_policy nss_blackhole_p
  * nss_blackhole_enqueue()
  *	Enqueue API for nss blackhole qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_blackhole_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_blackhole_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 /*
@@ -49,6 +58,7 @@ static struct sk_buff *nss_blackhole_deq
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_blackhole_drop()
  *	The following function drops a packet from HLOS queue.
@@ -60,6 +70,7 @@ static unsigned int nss_blackhole_drop(s
 	nss_qdisc_info("qdisc %x dropping\n", sch->handle);
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 /*
  * nss_blackhole_reset()
@@ -92,9 +103,15 @@ static void nss_blackhole_destroy(struct
  * nss_blackhole_change()
  *	Function call used to configure the parameters of the nss blackhole qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_blackhole_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_blackhole_change(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_blackhole_sched_data *q;
+	struct nlattr *tb[TCA_NSSBLACKHOLE_MAX + 1];
 	struct tc_nssblackhole_qopt *qopt;
 	struct nss_if_msg nim;
 
@@ -102,7 +119,11 @@ static int nss_blackhole_change(struct Q
 		return 0;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_blackhole_policy, TCA_NSSBLACKHOLE_MAX, TCA_NSSBLACKHOLE_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_blackhole_policy, tb, TCA_NSSBLACKHOLE_MAX, TCA_NSSBLACKHOLE_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_blackhole_policy, tb, TCA_NSSBLACKHOLE_MAX, TCA_NSSBLACKHOLE_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -154,9 +175,17 @@ static int nss_blackhole_change(struct Q
  * nss_blackhole_init()
  *	Initializes a nss blackhole qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_blackhole_init(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_blackhole_init(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_qdisc *nq = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSBLACKHOLE_MAX + 1];
 	struct tc_nssblackhole_qopt *qopt;
 	unsigned int accel_mode;
 
@@ -166,7 +195,11 @@ static int nss_blackhole_init(struct Qdi
 	if (!opt) {
 		accel_mode = TCA_NSS_ACCEL_MODE_PPE;
 	} else {
-		qopt = nss_qdisc_qopt_get(opt, nss_blackhole_policy, TCA_NSSBLACKHOLE_MAX, TCA_NSSBLACKHOLE_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+		qopt = nss_qdisc_qopt_get(opt, nss_blackhole_policy, tb, TCA_NSSBLACKHOLE_MAX, TCA_NSSBLACKHOLE_PARMS);
+#else
+		qopt = nss_qdisc_qopt_get(opt, nss_blackhole_policy, tb, TCA_NSSBLACKHOLE_MAX, TCA_NSSBLACKHOLE_PARMS, extack);
+#endif
 		if (!qopt) {
 			return -EINVAL;
 		}
@@ -176,12 +209,17 @@ static int nss_blackhole_init(struct Qdi
 	nss_qdisc_info("qdisc %x initializing\n", sch->handle);
 	nss_blackhole_reset(sch);
 
-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, accel_mode) < 0) {
+	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, accel_mode, extack) < 0)
+	{
 		return -EINVAL;
 	}
 
 	nss_qdisc_info("qdisc %x initialized with parent %x\n", sch->handle, sch->parent);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_blackhole_change(sch, opt) < 0) {
+#else
+	if (nss_blackhole_change(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(nq);
 		return -EINVAL;
 	}
@@ -214,7 +252,7 @@ static int nss_blackhole_dump(struct Qdi
 	opt.set_default = q->set_default;
 	opt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL) {
 		goto nla_put_failure;
 	}
@@ -251,7 +289,9 @@ struct Qdisc_ops nss_blackhole_qdisc_ops
 	.enqueue	=	nss_blackhole_enqueue,
 	.dequeue	=	nss_blackhole_dequeue,
 	.peek		=	nss_blackhole_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_blackhole_drop,
+#endif
 	.init		=	nss_blackhole_init,
 	.reset		=	nss_blackhole_reset,
 	.destroy	=	nss_blackhole_destroy,
--- a/nss_qdisc/nss_codel.c
+++ b/nss_qdisc/nss_codel.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2016-2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2018, 2020,  The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -76,9 +76,18 @@ static struct nla_policy nss_codel_polic
  * nss_codel_enqueue()
  *	Enqueue a packet into nss_codel queue in NSS firmware (bounce).
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 /*
@@ -90,6 +99,7 @@ static struct sk_buff *nss_codel_dequeue
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_codel_drop()
  *	Drops a packet from the bounce complete queue.
@@ -100,6 +110,7 @@ static unsigned int nss_codel_drop(struc
 {
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 /*
  * nss_codel_reset()
@@ -234,9 +245,15 @@ static int nss_codel_mem_sz_get(struct Q
  * nss_codel_change()
  *	Used to configure the nss_codel queue in NSS firmware.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_codel_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_codel_change(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_codel_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSCODEL_MAX + 1];
 	struct tc_nsscodel_qopt *qopt;
 	struct nss_if_msg nim;
 	struct net_device *dev = qdisc_dev(sch);
@@ -245,7 +262,11 @@ static int nss_codel_change(struct Qdisc
 	struct nss_shaper_node_config *config;
 	bool free_flow_queue = true;
 
-	qopt = nss_qdisc_qopt_get(opt, nss_codel_policy, TCA_NSSCODEL_MAX, TCA_NSSCODEL_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_codel_policy, tb, TCA_NSSCODEL_MAX, TCA_NSSCODEL_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_codel_policy, tb, TCA_NSSCODEL_MAX, TCA_NSSCODEL_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -381,16 +402,28 @@ fail:
  * nss_codel_init()
  *	Initializes the nss_codel qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_codel_init(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_codel_init(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_qdisc *nq = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSCODEL_MAX + 1];
 	struct tc_nsscodel_qopt *qopt;
 
 	if (!opt) {
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_codel_policy, TCA_NSSCODEL_MAX, TCA_NSSCODEL_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_codel_policy, tb, TCA_NSSCODEL_MAX, TCA_NSSCODEL_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_codel_policy, tb, TCA_NSSCODEL_MAX, TCA_NSSCODEL_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -404,7 +437,8 @@ static int nss_codel_init(struct Qdisc *
 	nss_qdisc_register_configure_callback(nq, nss_codel_configure_callback);
 	nss_qdisc_register_stats_callback(nq, nss_codel_stats_callback);
 
-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_CODEL, 0, qopt->accel_mode) < 0) {
+	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_CODEL, 0, qopt->accel_mode, extack) < 0)
+	{
 		return -EINVAL;
 	}
 
@@ -412,7 +446,11 @@ static int nss_codel_init(struct Qdisc *
 		return -EINVAL;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_codel_change(sch, opt) < 0) {
+#else
+	if (nss_codel_change(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(nq);
 		return -EINVAL;
 	}
@@ -451,7 +489,7 @@ static int nss_codel_dump(struct Qdisc *
 	opt.flows = q->flows;
 	opt.ecn = q->ecn;
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL) {
 		goto nla_put_failure;
 	}
@@ -511,7 +549,9 @@ struct Qdisc_ops nss_codel_qdisc_ops __r
 	.enqueue	=	nss_codel_enqueue,
 	.dequeue	=	nss_codel_dequeue,
 	.peek		=	nss_codel_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_codel_drop,
+#endif
 	.init		=	nss_codel_init,
 	.reset		=	nss_codel_reset,
 	.destroy	=	nss_codel_destroy,
@@ -530,7 +570,9 @@ struct Qdisc_ops nss_fq_codel_qdisc_ops
 	.enqueue	=	nss_codel_enqueue,
 	.dequeue	=	nss_codel_dequeue,
 	.peek		=	nss_codel_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_codel_drop,
+#endif
 	.init		=	nss_codel_init,
 	.reset		=	nss_codel_reset,
 	.destroy	=	nss_codel_destroy,
--- a/nss_qdisc/nss_fifo.c
+++ b/nss_qdisc/nss_fifo.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2016-2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -29,9 +29,18 @@ static struct nla_policy nss_fifo_policy
 	[TCA_NSSFIFO_PARMS] = { .len = sizeof(struct tc_nssfifo_qopt) },
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_fifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_fifo_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 static struct sk_buff *nss_fifo_dequeue(struct Qdisc *sch)
@@ -39,11 +48,13 @@ static struct sk_buff *nss_fifo_dequeue(
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static unsigned int nss_fifo_drop(struct Qdisc *sch)
 {
 	nss_qdisc_info("nss_fifo dropping");
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 static void nss_fifo_reset(struct Qdisc *sch)
 {
@@ -64,8 +75,14 @@ static void nss_fifo_destroy(struct Qdis
 	nss_qdisc_info("nss_fifo destroyed");
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_fifo_params_validate_and_save(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_fifo_params_validate_and_save(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
+	struct nlattr *tb[TCA_NSSFIFO_MAX + 1];
 	struct tc_nssfifo_qopt *qopt;
 	struct nss_fifo_sched_data *q = qdisc_priv(sch);
 	bool is_bfifo = (sch->ops == &nss_bfifo_qdisc_ops);
@@ -74,7 +91,11 @@ static int nss_fifo_params_validate_and_
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_fifo_policy, TCA_NSSFIFO_MAX, TCA_NSSFIFO_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_fifo_policy, tb, TCA_NSSFIFO_MAX, TCA_NSSFIFO_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_fifo_policy, tb, TCA_NSSFIFO_MAX, TCA_NSSFIFO_PARMS, extack);
+#endif
 	if (!qopt) {
 		nss_qdisc_warning("Invalid input to fifo %x", sch->handle);
 		return -EINVAL;
@@ -101,7 +122,11 @@ static int nss_fifo_params_validate_and_
 }
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_fifo_ppe_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_fifo_ppe_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_fifo_sched_data *q = qdisc_priv(sch);
 	struct nss_qdisc *nq = &q->nq;
@@ -150,29 +175,46 @@ fail:
 	/*
 	 * Fallback to nss qdisc if PPE Qdisc configuration failed at init time.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_ppe_fallback_to_nss(&q->nq, opt) < 0) {
-		nss_qdisc_warning("nss_fifo %x fallback to nss failed\n", sch->handle);
+#else
+	if (nss_ppe_fallback_to_nss(&q->nq, opt, extack) < 0) {
+#endif
+	nss_qdisc_warning("nss_fifo %x fallback to nss failed\n", sch->handle);
 		return -EINVAL;
 	}
 	return 0;
 }
 #endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_fifo_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_fifo_change(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_fifo_sched_data *q = qdisc_priv(sch);
 	struct nss_qdisc *nq = &q->nq;
 	struct nss_if_msg nim;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_fifo_params_validate_and_save(sch, opt) < 0) {
-		nss_qdisc_warning("nss_fifo %p params validate and save failed\n", sch);
+#else
+	if (nss_fifo_params_validate_and_save(sch, opt, extack) < 0) {
+#endif
+		nss_qdisc_warning("nss_fifo %px params validate and save failed\n", sch);
 		return -EINVAL;
 	}
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (nq->mode == NSS_QDISC_MODE_PPE) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 		if (nss_fifo_ppe_change(sch, opt) < 0) {
-			nss_qdisc_warning("nss_fifo %p params validate and save failed\n", sch);
+#else
+		if (nss_fifo_ppe_change(sch, opt, extack) < 0) {
+#endif
+			nss_qdisc_warning("nss_fifo %px params validate and save failed\n", sch);
 			return -EINVAL;
 		}
 		return 0;
@@ -183,7 +225,7 @@ static int nss_fifo_change(struct Qdisc
 	nim.msg.shaper_configure.config.msg.shaper_node_config.snc.fifo_param.limit = q->limit;
 	nim.msg.shaper_configure.config.msg.shaper_node_config.snc.fifo_param.drop_mode = NSS_SHAPER_FIFO_DROP_MODE_TAIL;
 	if (nss_qdisc_configure(&q->nq, &nim, NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_CHANGE_PARAM) < 0) {
-		nss_qdisc_error("nss_fifo %p configuration failed\n", sch);
+		nss_qdisc_error("nss_fifo %px configuration failed\n", sch);
 		return -EINVAL;
 	}
 
@@ -199,7 +241,7 @@ static int nss_fifo_change(struct Qdisc
 	 * Set this qdisc to be the default qdisc for enqueuing packets.
 	 */
 	if (nss_qdisc_set_default(nq) < 0) {
-		nss_qdisc_error("nss_fifo %p set_default failed\n", sch);
+		nss_qdisc_error("nss_fifo %px set_default failed\n", sch);
 		return -EINVAL;
 	}
 
@@ -208,9 +250,17 @@ static int nss_fifo_change(struct Qdisc
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_fifo_init(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_fifo_init(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_qdisc *nq = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSFIFO_MAX + 1];
 	struct tc_nssfifo_qopt *qopt;
 
 	if (!opt) {
@@ -220,19 +270,28 @@ static int nss_fifo_init(struct Qdisc *s
 	nss_qdisc_info("Initializing Fifo - type %d\n", NSS_SHAPER_NODE_TYPE_FIFO);
 	nss_fifo_reset(sch);
 
-	qopt = nss_qdisc_qopt_get(opt, nss_fifo_policy, TCA_NSSFIFO_MAX, TCA_NSSFIFO_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_fifo_policy, tb, TCA_NSSFIFO_MAX, TCA_NSSFIFO_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_fifo_policy, tb, TCA_NSSFIFO_MAX, TCA_NSSFIFO_PARMS, extack);
+#endif
 	if (!qopt) {
 		nss_qdisc_warning("Invalid input to fifo %x", sch->handle);
 		return -EINVAL;
 	}
 
-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, qopt->accel_mode) < 0) {
+	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, qopt->accel_mode, extack) < 0)
+	{
 		nss_qdisc_warning("Fifo %x init failed", sch->handle);
 		return -EINVAL;
 	}
 
 	nss_qdisc_info("NSS fifo initialized - handle %x parent %x\n", sch->handle, sch->parent);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_fifo_change(sch, opt) < 0) {
+#else
+	if (nss_fifo_change(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(nq);
 		return -EINVAL;
 	}
@@ -262,7 +321,8 @@ static int nss_fifo_dump(struct Qdisc *s
 	opt.set_default = q->set_default;
 	opt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
+
 	if (opts == NULL) {
 		goto nla_put_failure;
 	}
@@ -290,7 +350,9 @@ struct Qdisc_ops nss_pfifo_qdisc_ops __r
 	.enqueue	=	nss_fifo_enqueue,
 	.dequeue	=	nss_fifo_dequeue,
 	.peek		=	nss_fifo_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_fifo_drop,
+#endif
 	.init		=	nss_fifo_init,
 	.reset		=	nss_fifo_reset,
 	.destroy	=	nss_fifo_destroy,
@@ -305,7 +367,9 @@ struct Qdisc_ops nss_bfifo_qdisc_ops __r
 	.enqueue	=	nss_fifo_enqueue,
 	.dequeue	=	nss_fifo_dequeue,
 	.peek		=	nss_fifo_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_fifo_drop,
+#endif
 	.init		=	nss_fifo_init,
 	.reset		=	nss_fifo_reset,
 	.destroy	=	nss_fifo_destroy,
--- a/nss_qdisc/nss_htb.c
+++ b/nss_qdisc/nss_htb.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -83,10 +83,16 @@ static inline struct nss_htb_class_data
  * nss_htb_class_params_validate_and_save()
  *	Validates and saves the qdisc configuration parameters.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_htb_class_params_validate_and_save(struct Qdisc *sch, struct nlattr **tca,
 					struct nss_htb_param *param)
+#else
+static int nss_htb_class_params_validate_and_save(struct Qdisc *sch, struct nlattr **tca,
+					struct nss_htb_param *param, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nlattr *opt = tca[TCA_OPTIONS];
+	struct nlattr *tb[TCA_NSSHTB_MAX + 1];
 	struct tc_nsshtb_class_qopt *qopt;
 	struct nss_htb_sched_data *q = qdisc_priv(sch);
 	struct net_device *dev = qdisc_dev(sch);
@@ -99,7 +105,11 @@ static int nss_htb_class_params_validate
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, TCA_NSSHTB_MAX, TCA_NSSHTB_CLASS_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, tb, TCA_NSSHTB_MAX, TCA_NSSHTB_CLASS_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, tb, TCA_NSSHTB_MAX, TCA_NSSHTB_CLASS_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -202,7 +212,7 @@ static struct nss_htb_class_data *nss_ht
 		return NULL;
 	}
 
-	nss_qdisc_trace("htb class %x allocated - addr %p\n", classid, cl);
+	nss_qdisc_trace("htb class %x allocated - addr %px\n", classid, cl);
 	cl->parent = parent;
 	cl->sch_common.classid = classid;
 
@@ -219,7 +229,7 @@ static struct nss_htb_class_data *nss_ht
 	 * reference count should not be 0.
 	 */
 	cl->qdisc = &noop_qdisc;
-	atomic_set(&cl->nq.refcnt, 1);
+	nss_qdisc_atomic_set(&cl->nq);
 
 	return cl;
 }
@@ -266,9 +276,16 @@ static int nss_htb_ppe_change_class(stru
  * nss_htb_change_class()
  *	Configures a new class.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_htb_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 		  struct nlattr **tca, unsigned long *arg)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_htb_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
+		  struct nlattr **tca, unsigned long *arg, struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_htb_sched_data *q = qdisc_priv(sch);
 	struct nss_htb_class_data *cl = (struct nss_htb_class_data *)*arg;
 	struct nss_htb_class_data *parent;
@@ -282,7 +299,11 @@ static int nss_htb_change_class(struct Q
 
 	nss_qdisc_trace("configuring htb class %x of qdisc %x\n", classid, sch->handle);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_htb_class_params_validate_and_save(sch, tca, &param) < 0) {
+#else
+	if (nss_htb_class_params_validate_and_save(sch, tca, &param, extack) < 0) {
+#endif
 		nss_qdisc_warning("validation of configuration parameters for htb class %x failed\n",
 					sch->handle);
 		return -EINVAL;
@@ -332,7 +353,8 @@ static int nss_htb_change_class(struct Q
 		 * here.
 		 */
 		cl->nq.parent = nq_parent;
-		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_HTB_GROUP, classid, accel_mode) < 0) {
+		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_HTB_GROUP, classid, accel_mode, extack) < 0)
+		{
 			nss_qdisc_error("nss_init for htb class %x failed\n", classid);
 			goto failure;
 		}
@@ -478,7 +500,7 @@ static void nss_htb_destroy_class(struct
 	/*
 	 * And now we destroy the child.
 	 */
-	qdisc_destroy(cl->qdisc);
+	 nss_qdisc_put(cl->qdisc);
 
 	/*
 	 * Stop the stats polling timer and free class
@@ -500,7 +522,11 @@ static void nss_htb_destroy_class(struct
  * nss_htb_delete_class()
  *	Detaches a class from operation, but does not destroy it.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+static int nss_htb_delete_class(struct Qdisc *sch, unsigned long arg, struct netlink_ext_ack *extack)
+#else
 static int nss_htb_delete_class(struct Qdisc *sch, unsigned long arg)
+#endif
 {
 	struct nss_htb_sched_data *q = qdisc_priv(sch);
 	struct nss_htb_class_data *cl = (struct nss_htb_class_data *)arg;
@@ -550,7 +576,7 @@ static int nss_htb_delete_class(struct Q
 	 * We simply deduct refcnt and return.
 	 */
 	if (!cl->parent) {
-		refcnt = atomic_sub_return(1, &cl->nq.refcnt);
+		refcnt = nss_qdisc_atomic_sub_return(&cl->nq);
 		sch_tree_unlock(sch);
 		return 0;
 	}
@@ -567,7 +593,7 @@ static int nss_htb_delete_class(struct Q
 	/*
 	 * Decrement refcnt and return
 	 */
-	refcnt = atomic_sub_return(1, &cl->nq.refcnt);
+	refcnt = nss_qdisc_atomic_sub_return(&cl->nq);
 	sch_tree_unlock(sch);
 
 	return 0;
@@ -577,7 +603,12 @@ static int nss_htb_delete_class(struct Q
  * nss_htb_graft_class()
  *	Replaces the qdisc attached to the provided class.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_htb_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new, struct Qdisc **old)
+#else
+static int nss_htb_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new, struct Qdisc **old,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_htb_class_data *cl = (struct nss_htb_class_data *)arg;
 	struct nss_if_msg nim_detach;
@@ -664,6 +695,7 @@ static void nss_htb_qlen_notify(struct Q
 	 */
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 /*
  * nss_htb_get_class()
  *	Fetches the class pointer if provided the classid.
@@ -695,10 +727,22 @@ static void nss_htb_put_class(struct Qdi
 	 * We are safe to destroy the qdisc if the reference count
 	 * goes down to 0.
 	 */
-	if (atomic_sub_return(1, &cl->nq.refcnt) == 0) {
+	if (nss_qdisc_atomic_sub_return(&cl->nq) == 0) {
 		nss_htb_destroy_class(sch, cl);
 	}
 }
+#else
+/*
+ * nss_htb_search_class()
+ *	Fetches the class pointer if provided the classid.
+ */
+static unsigned long nss_htb_search_class(struct Qdisc *sch, u32 classid)
+{
+	struct nss_htb_class_data *cl = nss_htb_find_class(classid, sch);
+
+	return (unsigned long)cl;
+}
+#endif
 
 /*
  * nss_htb_dump_class()
@@ -728,8 +772,7 @@ static int nss_htb_dump_class(struct Qdi
 	tcm->tcm_handle = cl->sch_common.classid;
 	tcm->tcm_info = cl->qdisc->handle;
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
-
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL || nla_put(skb, TCA_NSSHTB_CLASS_PARMS, sizeof(qopt), &qopt)) {
 		goto nla_put_failure;
 	}
@@ -750,7 +793,7 @@ static int nss_htb_dump_class_stats(stru
 {
 	struct nss_qdisc *nq = (struct nss_qdisc *)arg;
 
-	if (nss_qdisc_gnet_stats_copy_basic(d, &nq->bstats) < 0 ||
+	if (nss_qdisc_gnet_stats_copy_basic(sch, d, &nq->bstats) < 0 ||
 			nss_qdisc_gnet_stats_copy_queue(d, &nq->qstats) < 0) {
 		nss_qdisc_error("htb class %x stats dump failed\n", nq->qos_tag);
 		return -1;
@@ -795,9 +838,15 @@ static void nss_htb_walk(struct Qdisc *s
  * nss_htb_change_qdisc()
  *	Can be used to configure a htb qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_htb_change_qdisc(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_htb_change_qdisc(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_htb_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSHTB_MAX + 1];
 	struct tc_nsshtb_qopt *qopt;
 
 	/*
@@ -820,7 +869,11 @@ static int nss_htb_change_qdisc(struct Q
 	/*
 	 * If it is not NULL, parse to get qopt.
 	 */
-	qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, TCA_NSSHTB_MAX, TCA_NSSHTB_QDISC_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, tb, TCA_NSSHTB_MAX, TCA_NSSHTB_QDISC_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, tb, TCA_NSSHTB_MAX, TCA_NSSHTB_QDISC_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -895,7 +948,7 @@ static void nss_htb_destroy_qdisc(struct
 			 * Reduce refcnt by 1 before destroying. This is to
 			 * ensure that polling of stat stops properly.
 			 */
-			atomic_sub(1, &cl->nq.refcnt);
+			 nss_qdisc_atomic_sub(&cl->nq);
 
 			/*
 			 * We are not root class. Therefore we reduce the children count
@@ -945,9 +998,17 @@ static void nss_htb_destroy_qdisc(struct
  * nss_htb_init_qdisc()
  *	Initializes the htb qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_htb_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_htb_init_qdisc(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_htb_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSHTB_MAX + 1];
 	struct tc_nsshtb_qopt *qopt;
 	int err;
 	unsigned int accel_mode;
@@ -964,7 +1025,11 @@ static int nss_htb_init_qdisc(struct Qdi
 	if (!opt) {
 		accel_mode = TCA_NSS_ACCEL_MODE_PPE;
 	} else {
-		qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, TCA_NSSHTB_MAX, TCA_NSSHTB_QDISC_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+		qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, tb, TCA_NSSHTB_MAX, TCA_NSSHTB_QDISC_PARMS);
+#else
+		qopt = nss_qdisc_qopt_get(opt, nss_htb_policy, tb, TCA_NSSHTB_MAX, TCA_NSSHTB_QDISC_PARMS, extack);
+#endif
 		if (!qopt) {
 			return -EINVAL;
 		}
@@ -977,7 +1042,7 @@ static int nss_htb_init_qdisc(struct Qdi
 	/*
 	 * Initialize the NSSHTB shaper in NSS
 	 */
-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_HTB, 0, accel_mode) < 0) {
+	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_HTB, 0, accel_mode, extack) < 0) {
 		nss_qdisc_error("failed to initialize htb qdisc %x in nss", sch->handle);
 		return -EINVAL;
 	}
@@ -987,7 +1052,11 @@ static int nss_htb_init_qdisc(struct Qdi
 	/*
 	 * Tune HTB parameters
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_htb_change_qdisc(sch, opt) < 0) {
+#else
+	if (nss_htb_change_qdisc(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(&q->nq);
 		return -EINVAL;
 	}
@@ -1016,7 +1085,8 @@ static int nss_htb_dump_qdisc(struct Qdi
 	qopt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
 	nss_qdisc_info("r2q = %u accel_mode = %u", qopt.r2q, qopt.accel_mode);
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (!opts || nla_put(skb, TCA_NSSHTB_QDISC_PARMS, sizeof(qopt), &qopt)) {
 		goto nla_put_failure;
 	}
@@ -1032,9 +1102,18 @@ static int nss_htb_dump_qdisc(struct Qdi
  * nss_htb_enqueue()
  *	Enqueues a skb to htb qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_htb_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_htb_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 /*
@@ -1046,6 +1125,7 @@ static struct sk_buff *nss_htb_dequeue(s
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_htb_drop()
  *	Drops a single skb from linux queue, if not empty.
@@ -1057,6 +1137,7 @@ static unsigned int nss_htb_drop(struct
 	nss_qdisc_trace("drop called on htb qdisc %x\n", sch->handle);
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 /*
  * Registration structure for htb class
@@ -1067,9 +1148,17 @@ const struct Qdisc_class_ops nss_htb_cla
 	.graft		= nss_htb_graft_class,
 	.leaf		= nss_htb_leaf_class,
 	.qlen_notify	= nss_htb_qlen_notify,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	.get		= nss_htb_get_class,
 	.put		= nss_htb_put_class,
+#else
+	.find		=	nss_htb_search_class,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	.tcf_chain	= nss_qdisc_tcf_chain,
+#else
+	.tcf_block	= nss_qdisc_tcf_block,
+#endif
 	.bind_tcf	= nss_qdisc_tcf_bind,
 	.unbind_tcf	= nss_qdisc_tcf_unbind,
 	.dump		= nss_htb_dump_class,
@@ -1090,7 +1179,9 @@ struct Qdisc_ops nss_htb_qdisc_ops __rea
 	.enqueue	= nss_htb_enqueue,
 	.dequeue	= nss_htb_dequeue,
 	.peek		= qdisc_peek_dequeued,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		= nss_htb_drop,
+#endif
 	.cl_ops		= &nss_htb_class_ops,
 	.priv_size	= sizeof(struct nss_htb_sched_data),
 	.owner		= THIS_MODULE
--- a/nss_qdisc/nss_ppe.c
+++ b/nss_qdisc/nss_ppe.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -391,10 +391,10 @@ static int nss_ppe_l1_res_free(struct ns
 	}
 
 	/*
-	 * Bridge interface will have one level less than the max shaper levels.
+	 * Loopback will have one level less than the max shaper levels.
 	 * L1 scheduler was configured at init time, so resources were allocated.
 	 */
-	if (nq->is_bridge) {
+	if (nq->needs_ppe_loopback) {
 		offset = npq->l0spid - nss_ppe_base_get(port_num, NSS_PPE_L0_SP);
 		if (nss_ppe_res_free(port_num, offset, NSS_PPE_L0_SP) != 0) {
 			nss_qdisc_error("Used res:%d not found for port:%d, type:%d\n", npq->l0spid, port_num, NSS_PPE_L0_SP);
@@ -465,10 +465,10 @@ static int nss_ppe_l1_res_alloc(struct n
 	}
 
 	/*
-	 * For bridge, we use loopback which has no dedicated L1 schedulers. L0
-	 * SP is the only resource we need to allocate.
+	 * Loopback has no dedicated L1 schedulers. L0 SP is the only resource we
+	 * need to allocate.
 	 */
-	if (nq->is_bridge) {
+	if (nq->needs_ppe_loopback) {
 		npq->l0spid = nss_ppe_base_get(port_num, NSS_PPE_L0_SP) + l0sp->offset;
 		npq->l1_valid = true;
 		nss_qdisc_info("Level1 scheduler resource allocation successful\n");
@@ -633,10 +633,10 @@ static int nss_ppe_l1_queue_scheduler_se
 	struct nss_ppe_qdisc *npq = &nq->npq;
 
 	/*
-	 * Bridge interface will have one level less than the max shaper levels.
+	 * Loopback will have one level less than the max shaper levels.
 	 * L1 scheduler was configured at init time, so no need to allocate resources.
 	 */
-	if (nq->is_bridge) {
+	if (nq->needs_ppe_loopback) {
 		/*
 		 * Allocate resource if we have not already done so.
 		 */
@@ -717,7 +717,6 @@ static int nss_ppe_l0_res_free(struct ns
 		return -EINVAL;
 	}
 
-
 	/*
 	 * Reset Res id values in qdisc
 	 */
@@ -1229,9 +1228,9 @@ static int nss_ppe_max_level_get(struct
 	int level = NSS_PPE_MAX_LEVEL;
 
 	/*
-	 * For bridge ports, one level is being used by loopback.
+	 * Loopback uses one level.
 	 */
-	if (nq->is_bridge) {
+	if (nq->needs_ppe_loopback) {
 		level = level - 1;
 	}
 
@@ -1252,7 +1251,7 @@ static void nss_ppe_attach_free(uint32_t
 	ppe_port->res_free[res->type] = res;
 	spin_unlock_bh(&ppe_port->lock);
 
-	nss_qdisc_info("port:%d, type:%d, res:%p\n", port, res->type, res);
+	nss_qdisc_info("port:%d, type:%d, res:%px\n", port, res->type, res);
 	return;
 }
 
@@ -1319,7 +1318,7 @@ int nss_ppe_res_free(uint32_t port, uint
 
 success:
 	nss_ppe_attach_free(port, res);
-	nss_qdisc_info("port:%d, type:%d, res:%p\n", port, type, res);
+	nss_qdisc_info("port:%d, type:%d, res:%px\n", port, type, res);
 	return 0;
 }
 
@@ -1345,7 +1344,7 @@ struct nss_ppe_res *nss_ppe_res_alloc(ui
 	}
 	spin_unlock_bh(&ppe_port->lock);
 
-	nss_qdisc_info("port:%d, type:%d, res:%p\n", port, type, res);
+	nss_qdisc_info("port:%d, type:%d, res:%px\n", port, type, res);
 	return res;
 }
 
@@ -1370,7 +1369,7 @@ static int nss_ppe_default_conf_set(uint
 	nss_ppe_all_queue_disable(port_num);
 
 	/*
-	 * No resources were allocated for Port 0 (bridge interface).
+	 * No resources were allocated for Port 0 (Loopback port).
 	 * L1 scheduler was configured at init time.
 	 */
 	if (port_num == 0) {
@@ -1669,7 +1668,6 @@ static int nss_ppe_scheduler_set(struct
 			nss_ppe_queue_disable(nq);
 		}
 	} else {
-
 		/*
 		 * When a classful qdisc say HTB is configured with max levels of hierarchy,
 		 * and then if a qdisc say FIFO is attached at the last level, we will have all
@@ -1775,7 +1773,7 @@ int nss_ppe_set_parent(struct Qdisc *sch
 	struct net_device *dev = qdisc_dev(sch);
 	struct nss_qdisc *parent_nq = NULL;
 	struct Qdisc *parent_qdisc = NULL;
-	unsigned long parent_class;
+	unsigned long parent_class = 0;
 
 	/*
 	 * PPE Qdisc cannot be attached to NSS Qdisc.
@@ -1788,7 +1786,7 @@ int nss_ppe_set_parent(struct Qdisc *sch
 	}
 
 	if ((parent_nq) && (parent_nq->mode == NSS_QDISC_MODE_NSS)) {
-		nss_qdisc_info("HW qdisc/class %p cannot be attached to nss qdisc/class\n", nq->qdisc);
+		nss_qdisc_info("HW qdisc/class %px cannot be attached to nss qdisc/class\n", nq->qdisc);
 		return NSS_PPE_QDISC_PARENT_NOT_PPE;
 	}
 
@@ -1810,21 +1808,26 @@ int nss_ppe_set_parent(struct Qdisc *sch
 		 */
 		if ((parent_nq) && (parent_nq->npq.sub_type != NSS_SHAPER_CONFIG_PPE_SN_TYPE_PRIO) && (TC_H_MIN(parent))) {
 			if (!parent_qdisc) {
-				nss_qdisc_info("HW qdisc/class %p cannot be attached to non-existing class %x\n", nq->qdisc, parent);
+				nss_qdisc_info("HW qdisc/class %px cannot be attached to non-existing class %x\n", nq->qdisc, parent);
 				return NSS_PPE_QDISC_PARENT_NOT_EXISTING;
 			}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 			parent_class = parent_qdisc->ops->cl_ops->get(parent_qdisc, parent);
-
+#else
+			parent_class = parent_qdisc->ops->cl_ops->find(parent_qdisc, parent);
+#endif
 			if (!parent_class) {
 				nq->parent = NULL;
-				nss_qdisc_info("HW qdisc/class %p cannot be attached to non-existing class %x\n", nq->qdisc, parent);
+				nss_qdisc_info("HW qdisc/class %px cannot be attached to non-existing class %x\n", nq->qdisc, parent);
 				return NSS_PPE_QDISC_PARENT_NOT_EXISTING;
 
 			}
 
 			nq->parent = (struct nss_qdisc *)parent_class;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 			parent_qdisc->ops->cl_ops->put(parent_qdisc, parent_class);
+#endif
 		}
 	}
 
@@ -1929,7 +1932,7 @@ int nss_ppe_port_num_get(struct nss_qdis
 	 * Fetch port number based on interface type.
 	 * TODO: Change this when API from DP is available
 	 */
-	if (!(nq->is_bridge)) {
+	if (!nq->needs_ppe_loopback) {
 		port_num = nq->nss_interface_number;
 	}
 
@@ -1938,6 +1941,32 @@ int nss_ppe_port_num_get(struct nss_qdis
 }
 
 /*
+ * nss_ppe_all_queue_enable_hybrid()
+ *	Enables PPE queues when NSS queuing Qdiscs are attached in the hieracrchy.
+ */
+void nss_ppe_all_queue_enable_hybrid(struct nss_qdisc *nq)
+{
+	struct nss_qdisc *nq_root = qdisc_priv(qdisc_root(nq->qdisc));
+
+	if (!nq_root->hybrid_configured) {
+		return;
+	}
+
+	/*
+	 * In case of hybrid mode, we disable the PPE queues until
+	 * queueing Qdisc is attached in the hierarchy.
+	 */
+	if((nq->type == NSS_SHAPER_NODE_TYPE_CODEL)
+		|| (nq->type == NSS_SHAPER_NODE_TYPE_FIFO)
+		|| (nq->type == NSS_SHAPER_NODE_TYPE_BF)
+		|| (nq->type == NSS_SHAPER_NODE_TYPE_WRED)) {
+		uint32_t port_num = nss_ppe_port_num_get(nq);
+		nss_ppe_all_queue_enable(port_num);
+		nss_qdisc_info("Queues in hybrid mode enabled successfully for Qdisc %px (type %d)\n", nq, nq->type);
+	}
+}
+
+/*
  * nss_ppe_node_detach()
  *	Configuration function that helps detach a child shaper node from a parent.
  */
@@ -1951,7 +1980,7 @@ int nss_ppe_node_detach(struct nss_qdisc
 	 */
 	if (nq_child->mode != NSS_QDISC_MODE_PPE) {
 		if (nss_qdisc_set_hybrid_mode(nq_child, NSS_QDISC_HYBRID_MODE_DISABLE, 0) < 0) {
-			nss_qdisc_warning("detach of old qdisc %p failed\n", nq_child->qdisc);
+			nss_qdisc_warning("detach of old qdisc %px failed\n", nq_child->qdisc);
 			return -EINVAL;
 		}
 
@@ -1960,7 +1989,7 @@ int nss_ppe_node_detach(struct nss_qdisc
 
 	nss_ppe_destroy(nq_child);
 
-	nss_qdisc_info("Qdisc:%p, node:%p\n", nq, nq_child);
+	nss_qdisc_info("Qdisc:%px, node:%px\n", nq, nq_child);
 	return 0;
 }
 
@@ -1999,10 +2028,10 @@ int nss_ppe_node_attach(struct nss_qdisc
 	}
 
 	/*
-	 * Return error in case NSS Qdisc is attached to PPE qdisc on bridge interface.
+	 * Return error in case NSS Qdisc is attached to loopback.
 	 */
-	if (nq->is_bridge) {
-		nss_qdisc_warning("NSS Qdisc cannot be attached to PPE Qdisc on bridge interface.\n");
+	if (nq->needs_ppe_loopback) {
+		nss_qdisc_warning("NSS Qdisc cannot be attached to PPE Qdisc on loopback interface.\n");
 		return -EINVAL;
 	}
 
@@ -2052,7 +2081,7 @@ int nss_ppe_node_attach(struct nss_qdisc
 
 	nq_root->hybrid_configured = true;
 
-	nss_qdisc_info("Qdisc:%p, node:%p\n", nq, nq_child);
+	nss_qdisc_info("Qdisc:%px, node:%px\n", nq, nq_child);
 	return 0;
 }
 
@@ -2176,14 +2205,22 @@ fail:
  * nss_ppe_fallback_to_nss()
  *	Calls the initialization of NSS Qdisc when PPE initialization fails.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 int nss_ppe_fallback_to_nss(struct nss_qdisc *nq, struct nlattr *opt)
+#else
+int nss_ppe_fallback_to_nss(struct nss_qdisc *nq, struct nlattr *opt, struct netlink_ext_ack *extack)
+#endif
 {
 	nss_qdisc_destroy(nq);
 
 	memset(&nq->npq, 0, sizeof(struct nss_ppe_qdisc));
 	nq->ppe_init_failed = true;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nq->qdisc->ops->init(nq->qdisc, opt) < 0) {
+#else
+	if (nq->qdisc->ops->init(nq->qdisc, opt, extack) < 0) {
+#endif
 			nss_qdisc_warning("Fallback to NSS Qdisc failed.\n");
 			return -EINVAL;
 	}
@@ -2218,7 +2255,7 @@ int nss_ppe_init(struct Qdisc *sch, stru
 	uint32_t port_num = nss_ppe_port_num_get(nq);
 
 	/*
-	 * HW qdisc is supported only on physical and bridge interfaces.
+	 * HW qdisc is supported only on physical and loopbaack ports.
 	 */
 	if (port_num >= NSS_PPE_PORT_MAX) {
 		nss_qdisc_info("HW qdisc not supported on port %d\n", port_num);
@@ -2300,7 +2337,7 @@ int nss_ppe_init(struct Qdisc *sch, stru
 		 * in qdisc that needs resource allocation in PPE. HTB qdisc on the other hand does
 		 * nothing useful and thus we don't allocate any resource".
 		 */
-		nss_qdisc_trace("Qdisc parent = %p, handle=%x\n", nq->parent,  nq->parent->qos_tag);
+		nss_qdisc_trace("Qdisc parent = %px, handle=%x\n", nq->parent,  nq->parent->qos_tag);
 		if ((nq->parent->npq.sub_type == NSS_SHAPER_CONFIG_PPE_SN_TYPE_HTB)) {
 			nq->npq.level = nq->parent->npq.level;
 		} else {
@@ -2317,7 +2354,7 @@ int nss_ppe_init(struct Qdisc *sch, stru
 	nq->mode = NSS_QDISC_MODE_PPE;
 	if (alloc_scheduler) {
 		if (nss_ppe_scheduler_set(nq) < 0) {
-			nss_qdisc_warning("%p SSDK scheduler configuration failed\n", sch);
+			nss_qdisc_warning("%px SSDK scheduler configuration failed\n", sch);
 			memset(&nq->npq, 0, sizeof(struct nss_ppe_qdisc));
 			nq->mode = NSS_QDISC_MODE_NSS;
 			return -1;
--- a/nss_qdisc/nss_ppe.h
+++ b/nss_qdisc/nss_ppe.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -242,6 +242,12 @@ extern int nss_ppe_set_parent(struct Qdi
 extern int nss_ppe_get_max_prio_bands(struct nss_qdisc *nq);
 
 /*
+ * nss_ppe_all_queue_enable_hybrid()
+ *	Enables PPE queues when NSS queuing Qdiscs are attached in the hieracrchy.
+ */
+extern void nss_ppe_all_queue_enable_hybrid(struct nss_qdisc *nq);
+
+/*
  * nss_ppe_node_detach()
  *	Configuration function that helps detach a child shaper node from a parent.
  */
@@ -263,7 +269,11 @@ extern int nss_ppe_configure(struct nss_
  * nss_ppe_fallback_to_nss()
  *	Calls the initialization of NSS Qdisc when PPE initialization fails.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 extern int nss_ppe_fallback_to_nss(struct nss_qdisc *nq, struct nlattr *opt);
+#else
+extern int nss_ppe_fallback_to_nss(struct nss_qdisc *nq, struct nlattr *opt, struct netlink_ext_ack *extack);
+#endif
 
 /*
  * nss_ppe_destroy()
--- a/nss_qdisc/nss_prio.c
+++ b/nss_qdisc/nss_prio.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -37,9 +37,18 @@ static struct nla_policy nss_prio_policy
  * nss_prio_enqueue()
  *	Enqueues a skb to nssprio qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_prio_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_prio_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 /*
@@ -51,6 +60,7 @@ static struct sk_buff *nss_prio_dequeue(
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_prio_drop()
  *	Drops a single skb from linux queue, if not empty.
@@ -61,6 +71,7 @@ static unsigned int nss_prio_drop(struct
 {
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 /*
  * nss_prio_peek()
@@ -117,7 +128,11 @@ static void nss_prio_destroy(struct Qdis
 		/*
 		 * We can now destroy it
 		 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
 		qdisc_destroy(q->queues[i]);
+#else
+		qdisc_put(q->queues[i]);
+#endif
 	}
 
 	/*
@@ -157,8 +172,14 @@ static int nss_prio_get_max_bands(struct
  * nss_prio_change()
  *	Function call to configure the nssprio parameters
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_prio_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_prio_change(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
+	struct nlattr *tb[TCA_NSSPRIO_MAX + 1];
 	struct nss_prio_sched_data *q;
 	struct tc_nssprio_qopt *qopt;
 
@@ -180,7 +201,11 @@ static int nss_prio_change(struct Qdisc
 		return 0;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_prio_policy, TCA_NSSPRIO_MAX, TCA_NSSPRIO_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_prio_policy, tb, TCA_NSSPRIO_MAX, TCA_NSSPRIO_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_prio_policy, tb, TCA_NSSPRIO_MAX, TCA_NSSPRIO_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -209,9 +234,17 @@ static int nss_prio_change(struct Qdisc
  * nss_prio_init()
  *	Initializes the nssprio qdisc
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_prio_init(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_prio_init(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_prio_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSPRIO_MAX + 1];
 	struct tc_nssprio_qopt *qopt;
 	int i;
 	unsigned int accel_mode;
@@ -223,21 +256,30 @@ static int nss_prio_init(struct Qdisc *s
 	if (!opt) {
 		accel_mode = TCA_NSS_ACCEL_MODE_PPE;
 	} else {
-		qopt = nss_qdisc_qopt_get(opt, nss_prio_policy, TCA_NSSPRIO_MAX, TCA_NSSPRIO_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+		qopt = nss_qdisc_qopt_get(opt, nss_prio_policy, tb, TCA_NSSPRIO_MAX, TCA_NSSPRIO_PARMS);
+#else
+		qopt = nss_qdisc_qopt_get(opt, nss_prio_policy, tb, TCA_NSSPRIO_MAX, TCA_NSSPRIO_PARMS, extack);
+#endif
 		if (!qopt) {
 			return -EINVAL;
 		}
 		accel_mode = qopt->accel_mode;
 	}
 
-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_PRIO, 0, accel_mode) < 0) {
+	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_PRIO, 0, accel_mode, extack) < 0)
+	{
 		return -EINVAL;
 	}
 
 	nss_qdisc_info("Nssprio initialized - handle %x parent %x\n",
 			sch->handle, sch->parent);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_prio_change(sch, opt) < 0) {
+#else
+	if (nss_prio_change(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(&q->nq);
 		return -EINVAL;
 	}
@@ -263,7 +305,7 @@ static int nss_prio_dump(struct Qdisc *s
 	qopt.bands = q->bands;
 	qopt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL || nla_put(skb, TCA_NSSPRIO_PARMS, sizeof(qopt), &qopt)) {
 		goto nla_put_failure;
 	}
@@ -279,8 +321,14 @@ nla_put_failure:
  * nss_prio_graft()
  *	Replaces existing child qdisc with the new qdisc that is passed.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_prio_graft(struct Qdisc *sch, unsigned long arg,
 				struct Qdisc *new, struct Qdisc **old)
+#else
+static int nss_prio_graft(struct Qdisc *sch, unsigned long arg,
+				struct Qdisc *new, struct Qdisc **old,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_prio_sched_data *q = qdisc_priv(sch);
 	struct nss_qdisc *nq_new = qdisc_priv(new);
@@ -300,10 +348,10 @@ static int nss_prio_graft(struct Qdisc *
 	*old = q->queues[band];
 	sch_tree_unlock(sch);
 
-	nss_qdisc_info("Grafting old: %p with new: %p\n", *old, new);
+	nss_qdisc_info("Grafting old: %px with new: %px\n", *old, new);
 	if (*old != &noop_qdisc) {
 		struct nss_qdisc *nq_old = qdisc_priv(*old);
-		nss_qdisc_info("Detaching old: %p\n", *old);
+		nss_qdisc_info("Detaching old: %px\n", *old);
 		nim_detach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = q->nq.qos_tag;
 
 		if (q->nq.mode == NSS_QDISC_MODE_NSS) {
@@ -365,6 +413,7 @@ static struct Qdisc *nss_prio_leaf(struc
 	return q->queues[band];
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 /*
  * nss_prio_get()
  *	Returns the band if provided the classid.
@@ -390,6 +439,24 @@ static void nss_prio_put(struct Qdisc *s
 {
 	nss_qdisc_info("Inside prio put\n");
 }
+#else
+/*
+ * nss_prio_search()
+ *	Returns the band if provided the classid.
+ */
+static unsigned long nss_prio_search(struct Qdisc *sch, u32 classid)
+{
+	struct nss_prio_sched_data *q = qdisc_priv(sch);
+	unsigned long band = TC_H_MIN(classid);
+
+	nss_qdisc_info("Inside get. Handle - %x Classid - %x Band %lu Available band %u\n", sch->handle, classid, band, q->bands);
+
+	if (band > q->bands)
+		return 0;
+
+	return band;
+}
+#endif
 
 /*
  * nss_prio_walk()
@@ -446,7 +513,7 @@ static int nss_prio_dump_class_stats(str
 	cl_q = q->queues[cl - 1];
 	cl_q->qstats.qlen = cl_q->q.qlen;
 
-	if (nss_qdisc_gnet_stats_copy_basic(d, &cl_q->bstats) < 0 ||
+	if (nss_qdisc_gnet_stats_copy_basic(sch, d, &cl_q->bstats) < 0 ||
 			nss_qdisc_gnet_stats_copy_queue(d, &cl_q->qstats) < 0)
 		return -1;
 
@@ -460,9 +527,17 @@ static int nss_prio_dump_class_stats(str
 const struct Qdisc_class_ops nss_prio_class_ops = {
 	.graft		=	nss_prio_graft,
 	.leaf		=	nss_prio_leaf,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	.get		=	nss_prio_get,
 	.put		=	nss_prio_put,
+#else
+	.find       =   nss_prio_search,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	.tcf_chain	=	nss_qdisc_tcf_chain,
+#else
+	.tcf_block	=	nss_qdisc_tcf_block,
+#endif
 	.bind_tcf	=	nss_qdisc_tcf_bind,
 	.unbind_tcf	=	nss_qdisc_tcf_unbind,
 	.walk		=	nss_prio_walk,
@@ -481,7 +556,9 @@ struct Qdisc_ops nss_prio_qdisc_ops __re
 	.enqueue	=	nss_prio_enqueue,
 	.dequeue	=	nss_prio_dequeue,
 	.peek		=	nss_prio_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_prio_drop,
+#endif
 	.init		=	nss_prio_init,
 	.reset		=	nss_prio_reset,
 	.destroy	=	nss_prio_destroy,
--- a/nss_qdisc/nss_qdisc.c
+++ b/nss_qdisc/nss_qdisc.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2019 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2021 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -14,6 +14,7 @@
  **************************************************************************
  */
 
+#include <nss_api_if.h>
 #include "nss_qdisc.h"
 #include "nss_fifo.h"
 #include "nss_codel.h"
@@ -68,12 +69,25 @@ static int nss_qdisc_ppe_init(struct Qdi
 	 * Fallback to NSS Qdisc if PPE Qdisc configuration failed.
 	 */
 	if (nq->ppe_init_failed) {
-		nss_qdisc_info("Qdisc %p (type %d) HW Qdisc initialization already tried, creating NSS Qdisc\n",
+		nss_qdisc_info("Qdisc %px (type %d) HW Qdisc initialization already tried, creating NSS Qdisc\n",
 			nq->qdisc, nq->type);
 		return 0;
 	}
 
 	/*
+	 * Bridge and IFB needs PPE looback port shapers.
+	 */
+	if (nq->is_bridge || nss_igs_verify_if_num(nq->nss_interface_number)) {
+		nss_qdisc_info("Qdisc %px (type %d) init qdisc: %px, needs PPE loopback port\n",
+			nq->qdisc, nq->type, nq->qdisc);
+		nq->needs_ppe_loopback = true;
+	} else {
+		nss_qdisc_info("Qdisc %px (type %d) init qdisc: %px, does not need PPE loopback port\n",
+			nq->qdisc, nq->type, nq->qdisc);
+		nq->needs_ppe_loopback = false;
+	}
+
+	/*
 	 * Set the parent of PPE qdisc.
 	 */
 	status = nss_ppe_set_parent(sch, nq, parent);
@@ -93,13 +107,13 @@ static int nss_qdisc_ppe_init(struct Qdi
 			 * Therefore fallback only applies to qdiscs.
 			 */
 			if (nq->is_class) {
-			nss_qdisc_error("Qdisc %p (type %d) initializing HW class failed", nq->qdisc, nq->type);
+			nss_qdisc_error("Qdisc %px (type %d) initializing HW class failed", nq->qdisc, nq->type);
 			return -1;
 		}
-		nss_qdisc_info("Qdisc %p (type %d) initializing HW Qdisc failed, initializing NSS Qdisc \n",
+		nss_qdisc_info("Qdisc %px (type %d) initializing HW Qdisc failed, initializing NSS Qdisc \n",
 			nq->qdisc, nq->type);
 	} else {
-		nss_qdisc_info("Qdisc %p (type %d) successfully created in PPE\n", nq->qdisc, nq->type);
+		nss_qdisc_info("Qdisc %px (type %d) successfully created in PPE\n", nq->qdisc, nq->type);
 	}
 
 	return 0;
@@ -190,7 +204,7 @@ static int nss_qdisc_attach_bshaper(stru
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("qdisc %p (type %d) is not ready: State - %d\n",
+		nss_qdisc_warning("qdisc %px (type %d) is not ready: State - %d\n",
 				sch, nq->type, state);
 		return -1;
 	}
@@ -283,7 +297,7 @@ static int nss_qdisc_detach_bshaper(stru
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("qdisc %p (type %d) is not ready: %d\n",
+		nss_qdisc_warning("qdisc %px (type %d) is not ready: %d\n",
 				sch, nq->type, state);
 		return -1;
 	}
@@ -475,7 +489,7 @@ nextdev:
  */
 static void nss_qdisc_root_cleanup_final(struct nss_qdisc *nq)
 {
-	nss_qdisc_info("Root qdisc %p (type %d) final cleanup\n",
+	nss_qdisc_info("Root qdisc %px (type %d) final cleanup\n",
 				nq->qdisc, nq->type);
 
 	/*
@@ -486,7 +500,7 @@ static void nss_qdisc_root_cleanup_final
 		/*
 		 * Unregister for bouncing to the NSS for bridge shaping
 		 */
-		nss_qdisc_info("Unregister for bridge bouncing: %p\n",
+		nss_qdisc_info("Unregister for bridge bouncing: %px\n",
 				nq->bounce_context);
 		nss_shaper_unregister_shaper_bounce_bridge(nq->nss_interface_number);
 
@@ -494,7 +508,7 @@ static void nss_qdisc_root_cleanup_final
 		 * Unregister the virtual interface we use to act as shaper
 		 * for bridge shaping.
 		 */
-		nss_qdisc_info("Release root bridge virtual interface: %p\n",
+		nss_qdisc_info("Release root bridge virtual interface: %px\n",
 				nq->virt_if_ctx);
 	}
 
@@ -507,7 +521,7 @@ static void nss_qdisc_root_cleanup_final
 		/*
 		 * Unregister for interface bouncing of packets
 		 */
-		nss_qdisc_info("Unregister for interface bouncing: %p\n",
+		nss_qdisc_info("Unregister for interface bouncing: %px\n",
 				nq->bounce_context);
 		nss_shaper_unregister_shaper_bounce_interface(nq->nss_interface_number);
 	}
@@ -534,7 +548,7 @@ static void nss_qdisc_root_cleanup_shape
 {
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_error("Root qdisc %p (type %d) shaper unsassign FAILED\n", nq->qdisc, nq->type);
+		nss_qdisc_error("Root qdisc %px (type %d) shaper unsassign FAILED\n", nq->qdisc, nq->type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_UNASSIGN_SHAPER_FAIL);
 		wake_up(&nq->wait_queue);
 		return;
@@ -553,7 +567,7 @@ static void nss_qdisc_root_cleanup_shape
 	nss_tx_status_t rc;
 	int msg_type;
 
-	nss_qdisc_info("Root qdisc %p (type %d): shaper unassign: %d\n",
+	nss_qdisc_info("Root qdisc %px (type %d): shaper unassign: %d\n",
 			nq->qdisc, nq->type, nq->shaper_id);
 
 	msg_type = nss_qdisc_get_interface_msg(nq->is_bridge, NSS_QDISC_IF_SHAPER_UNASSIGN);
@@ -571,7 +585,7 @@ static void nss_qdisc_root_cleanup_shape
 		return;
 	}
 
-	nss_qdisc_error("Root qdisc %p (type %d): unassign command send failed: "
+	nss_qdisc_error("Root qdisc %px (type %d): unassign command send failed: "
 		"%d, shaper id: %d\n", nq->qdisc, nq->type, rc, nq->shaper_id);
 
 	atomic_set(&nq->state, NSS_QDISC_STATE_UNASSIGN_SHAPER_SEND_FAIL);
@@ -587,7 +601,7 @@ static void nss_qdisc_root_cleanup_free_
 {
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_error("Root qdisc %p (type %d) free FAILED response "
+		nss_qdisc_error("Root qdisc %px (type %d) free FAILED response "
 					"type: %d\n", nq->qdisc, nq->type,
 					nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_NODE_FREE_FAIL);
@@ -595,7 +609,7 @@ static void nss_qdisc_root_cleanup_free_
 		return;
 	}
 
-	nss_qdisc_info("Root qdisc %p (type %d) free SUCCESS - response "
+	nss_qdisc_info("Root qdisc %px (type %d) free SUCCESS - response "
 			"type: %d\n", nq->qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 
@@ -612,7 +626,7 @@ static void nss_qdisc_root_cleanup_free_
 	nss_tx_status_t rc;
 	int msg_type;
 
-	nss_qdisc_info("Root qdisc %p (type %d): freeing shaper node\n",
+	nss_qdisc_info("Root qdisc %px (type %d): freeing shaper node\n",
 			nq->qdisc, nq->type);
 
 	/*
@@ -634,7 +648,7 @@ static void nss_qdisc_root_cleanup_free_
 		return;
 	}
 
-	nss_qdisc_error("Qdisc %p (type %d): free command send "
+	nss_qdisc_error("Qdisc %px (type %d): free command send "
 		"failed: %d, qos tag: %x\n", nq->qdisc, nq->type,
 		rc, nq->qos_tag);
 
@@ -652,7 +666,7 @@ static void nss_qdisc_root_init_root_ass
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_warning("Root assign FAILED for qdisc %p (type %d), "
+		nss_qdisc_warning("Root assign FAILED for qdisc %px (type %d), "
 			"response type: %d\n", nq->qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 		nq->pending_final_state = NSS_QDISC_STATE_ROOT_SET_FAIL;
@@ -660,7 +674,7 @@ static void nss_qdisc_root_init_root_ass
 		return;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): set as root is done. Response - %d"
+	nss_qdisc_info("Qdisc %px (type %d): set as root is done. Response - %d"
 			, nq->qdisc, nq->type, nim->msg.shaper_configure.config.response_type);
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 	wake_up(&nq->wait_queue);
@@ -678,7 +692,7 @@ static void nss_qdisc_root_init_alloc_no
 	int msg_type;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_info("Qdisc %p (type %d) root alloc node FAILED "
+		nss_qdisc_info("Qdisc %px (type %d) root alloc node FAILED "
 			"response type: %d\n", nq->qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 
@@ -691,7 +705,7 @@ static void nss_qdisc_root_init_alloc_no
 		return;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d), shaper node alloc success: %u\n",
+	nss_qdisc_info("Qdisc %px (type %d), shaper node alloc success: %u\n",
 				nq->qdisc, nq->type, nq->shaper_id);
 
 	/*
@@ -752,7 +766,7 @@ static void nss_qdisc_root_init_shaper_a
 	 * Shaper has been allocated and assigned
 	 */
 	nq->shaper_id = nim->msg.shaper_assign.new_shaper_id;
-	nss_qdisc_info("Qdisc %p (type %d), shaper assigned: %u\n",
+	nss_qdisc_info("Qdisc %px (type %d), shaper assigned: %u\n",
 				nq->qdisc, nq->type, nq->shaper_id);
 
 	/*
@@ -774,14 +788,13 @@ static void nss_qdisc_root_init_shaper_a
 	/*
 	 * Unable to send alloc node command, cleanup from unassigning the shaper
 	 */
-	nss_qdisc_warning("Qdisc %p (type %d) create command failed: %d\n",
+	nss_qdisc_warning("Qdisc %px (type %d) create command failed: %d\n",
 			nq->qdisc, nq->type, rc);
 
 	nq->pending_final_state = NSS_QDISC_STATE_NODE_ALLOC_SEND_FAIL;
 	nss_qdisc_root_cleanup_shaper_unassign(nq);
 }
 
-
 /*
  * nss_qdisc_child_cleanup_final()
  *	Perform final cleanup of a shaper node after all shaper node
@@ -789,7 +802,7 @@ static void nss_qdisc_root_init_shaper_a
  */
 static void nss_qdisc_child_cleanup_final(struct nss_qdisc *nq)
 {
-	nss_qdisc_info("Final cleanup type %d: %p\n",
+	nss_qdisc_info("Final cleanup type %d: %px\n",
 			nq->type, nq->qdisc);
 
 	/*
@@ -805,7 +818,6 @@ static void nss_qdisc_child_cleanup_fina
 	wake_up(&nq->wait_queue);
 }
 
-
 /*
  * nss_qdisc_child_cleanup_free_node_callback()
  *	Invoked on the response to freeing a child shaper node
@@ -816,14 +828,14 @@ static void nss_qdisc_child_cleanup_free
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_error("Qdisc %p (type %d qos_tag %x): child free FAILED response type: %d\n",
+		nss_qdisc_error("Qdisc %px (type %d qos_tag %x): child free FAILED response type: %d\n",
 			nq->qdisc, nq->type, nq->qos_tag, nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_NODE_FREE_FAIL);
 		wake_up(&nq->wait_queue);
 		return;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): child shaper node "
+	nss_qdisc_info("Qdisc %px (type %d): child shaper node "
 			"free complete\n", nq->qdisc, nq->type);
 
 	/*
@@ -842,7 +854,7 @@ static void nss_qdisc_child_cleanup_free
 	nss_tx_status_t rc;
 	int msg_type;
 
-	nss_qdisc_info("Qdisc %p (type %d qos_tag %x): free shaper node command\n",
+	nss_qdisc_info("Qdisc %px (type %d qos_tag %x): free shaper node command\n",
 			nq->qdisc, nq->type, nq->qos_tag);
 
 	/*
@@ -860,7 +872,7 @@ static void nss_qdisc_child_cleanup_free
 		return;
 	}
 
-	nss_qdisc_error("Qdisc %p (type %d): child free node command send "
+	nss_qdisc_error("Qdisc %px (type %d): child free node command send "
 			"failed: %d, qos tag: %x\n", nq->qdisc, nq->type,
 			rc, nq->qos_tag);
 
@@ -877,7 +889,7 @@ static void nss_qdisc_child_init_alloc_n
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_error("Qdisc %p (type %d): child alloc node FAILED, response "
+		nss_qdisc_error("Qdisc %px (type %d): child alloc node FAILED, response "
 			"type: %d\n", nq->qdisc, nq->type, nim->msg.shaper_configure.config.response_type);
 		/*
 		 * Cleanup from final stage
@@ -890,7 +902,7 @@ static void nss_qdisc_child_init_alloc_n
 	/*
 	 * Shaper node has been allocated
 	 */
-	nss_qdisc_info("Qdisc %p (type %d): shaper node successfully "
+	nss_qdisc_info("Qdisc %px (type %d): shaper node successfully "
 			"created as a child node\n", nq->qdisc, nq->type);
 
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
@@ -915,7 +927,11 @@ static inline void nss_qdisc_add_to_tail
 	 * We do not use the qdisc_enqueue_tail() API here in order
 	 * to prevent stats from getting updated by the API.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	__skb_queue_tail(&sch->q, skb);
+#else
+	__qdisc_enqueue_tail(skb, &sch->q);
+#endif
 
 	spin_unlock_bh(&nq->bounce_protection_lock);
 };
@@ -930,7 +946,11 @@ static inline void nss_qdisc_add_to_tail
 	 * We do not use the qdisc_enqueue_tail() API here in order
 	 * to prevent stats from getting updated by the API.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	__skb_queue_tail(&sch->q, skb);
+#else
+	__qdisc_enqueue_tail(skb, &sch->q);
+#endif
 };
 
 /*
@@ -952,10 +972,12 @@ static inline struct sk_buff *nss_qdisc_
 	 * We use __skb_dequeue() to ensure that
 	 * stats don't get updated twice.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
 	skb = __skb_dequeue(&sch->q);
-
+#else
+	skb = __qdisc_dequeue_head(&sch->q);
+#endif
 	spin_unlock_bh(&nq->bounce_protection_lock);
-
 	return skb;
 };
 
@@ -969,7 +991,11 @@ static inline struct sk_buff *nss_qdisc_
 	 * We use __skb_dequeue() to ensure that
 	 * stats don't get updated twice.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0))
 	return __skb_dequeue(&sch->q);
+#else
+	return __qdisc_dequeue_head(&sch->q);
+#endif
 };
 
 /*
@@ -1047,24 +1073,33 @@ struct Qdisc *nss_qdisc_replace(struct Q
  * nss_qdisc_qopt_get()
  *	Extracts qopt from opt.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 void *nss_qdisc_qopt_get(struct nlattr *opt, struct nla_policy *policy,
-				uint32_t tca_max, uint32_t tca_params)
+				struct nlattr *tb[], uint32_t tca_max, uint32_t tca_params)
+#else
+void *nss_qdisc_qopt_get(struct nlattr *opt, struct nla_policy *policy,
+				struct nlattr *tb[], uint32_t tca_max, uint32_t tca_params, struct netlink_ext_ack *extack)
+#endif
 {
-	struct nlattr *na[tca_max + 1];
 	int err;
 
 	if (!opt) {
 		return NULL;
 	}
 
-	err = nla_parse_nested(na, tca_max, opt, policy);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	err = nla_parse_nested(tb, tca_max, opt, policy);
+#else
+	err = nla_parse_nested_deprecated(tb, tca_max, opt, policy, extack);
+#endif
+
 	if (err < 0)
 		return NULL;
 
-	if (na[tca_params] == NULL)
+	if (tb[tca_params] == NULL)
 		return NULL;
 
-	return nla_data(na[tca_params]);
+	return nla_data(tb[tca_params]);
 }
 
 /*
@@ -1090,16 +1125,17 @@ struct sk_buff *nss_qdisc_peek(struct Qd
 	struct sk_buff *skb;
 
 	if (!nq->is_virtual) {
-		skb = skb_peek(&sch->q);
+		skb = qdisc_peek_head(sch);
 	} else {
 		spin_lock_bh(&nq->bounce_protection_lock);
-		skb = skb_peek(&sch->q);
+		skb = qdisc_peek_head(sch);
 		spin_unlock_bh(&nq->bounce_protection_lock);
 	}
 
 	return skb;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_qdisc_drop()
  *	Called to drop the packet at the head of queue
@@ -1122,6 +1158,7 @@ unsigned int nss_qdisc_drop(struct Qdisc
 
 	return ret;
 }
+#endif
 
 /*
  * nss_qdisc_reset()
@@ -1131,7 +1168,7 @@ void nss_qdisc_reset(struct Qdisc *sch)
 {
 	struct nss_qdisc *nq = qdisc_priv(sch);
 
-	nss_qdisc_info("Qdisc %p (type %d) resetting\n",
+	nss_qdisc_info("Qdisc %px (type %d) resetting\n",
 			sch, nq->type);
 
 	/*
@@ -1148,7 +1185,7 @@ void nss_qdisc_reset(struct Qdisc *sch)
 		spin_unlock_bh(&nq->bounce_protection_lock);
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d) reset complete\n",
+	nss_qdisc_info("Qdisc %px (type %d) reset complete\n",
 			sch, nq->type);
 }
 
@@ -1169,7 +1206,11 @@ static bool nss_qdisc_iterate_fl(struct
 		return 0;
 	}
 
-	status = tc_classify(skb, tcf, &res, false);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0))
+	status = tcf_classify(skb, tcf, &res, false);
+#else
+	status = tcf_classify(skb, NULL, tcf, &res, false);
+#endif
 	if ((status == TC_ACT_STOLEN) || (status == TC_ACT_QUEUED)) {
 		return 1;
 	}
@@ -1191,7 +1232,11 @@ static bool nss_qdisc_iterate_fl(struct
  * nss_qdisc_enqueue()
  *	Generic enqueue call for enqueuing packets into NSS for shaping
  */
-int nss_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
+extern int nss_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+extern int nss_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+#endif
 {
 	struct nss_qdisc *nq = qdisc_priv(sch);
 	nss_tx_status_t status;
@@ -1200,8 +1245,8 @@ int nss_qdisc_enqueue(struct sk_buff *sk
 	 * If we are not the root qdisc then we should not be getting packets!!
 	 */
 	if (unlikely(!nq->is_root)) {
-		nss_qdisc_error("Qdisc %p (type %d): unexpected packet "
-			"for child qdisc - skb: %p\n", sch, nq->type, skb);
+		nss_qdisc_error("Qdisc %px (type %d): unexpected packet "
+			"for child qdisc - skb: %px\n", sch, nq->type, skb);
 		nss_qdisc_add_to_tail(skb, sch);
 		__netif_schedule(sch);
 		return NET_XMIT_SUCCESS;
@@ -1251,11 +1296,18 @@ int nss_qdisc_enqueue(struct sk_buff *sk
 	/*
 	 * Skip the shaping of already shaped packets.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	if (skb->tc_verd & TC_NCLS_NSS) {
 		skb->tc_verd = CLR_TC_NCLS_NSS(skb->tc_verd);
 		nss_qdisc_mark_and_schedule(nq->qdisc, skb);
 		return NET_XMIT_SUCCESS;
 	}
+#else
+	if (skb_skip_tc_classify_offload(skb)) {
+		nss_qdisc_mark_and_schedule(nq->qdisc, skb);
+		return NET_XMIT_SUCCESS;
+	}
+#endif
 
 	if (!nq->is_virtual) {
 		/*
@@ -1277,7 +1329,7 @@ int nss_qdisc_enqueue(struct sk_buff *sk
 			return NET_XMIT_SUCCESS;
 		}
 
-		nss_qdisc_trace("Qdisc %p (type %d): failed to bounce for bridge %d, skb: %p\n",
+		nss_qdisc_trace("Qdisc %px (type %d): failed to bounce for bridge %d, skb: %px\n",
 					sch, nq->type, nq->nss_interface_number, skb);
 		goto enqueue_drop;
 	}
@@ -1295,8 +1347,8 @@ int nss_qdisc_enqueue(struct sk_buff *sk
 	/*
 	 * We failed to bounce the packet for shaping on a virtual interface
 	 */
-	nss_qdisc_trace("Qdisc %p (type %d): failed to bounce for "
-		"interface: %d, skb: %p\n", sch, nq->type,
+	nss_qdisc_trace("Qdisc %px (type %d): failed to bounce for "
+		"interface: %d, skb: %px\n", sch, nq->type,
 		nq->nss_interface_number, skb);
 
 enqueue_drop:
@@ -1304,12 +1356,15 @@ enqueue_drop:
 	 * We were unable to transmit the packet for bridge shaping.
 	 * We therefore drop it.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	kfree_skb(skb);
 
 	spin_lock_bh(&nq->lock);
 	sch->qstats.drops++;
 	spin_unlock_bh(&nq->lock);
-
+#else
+	qdisc_drop(skb, sch, to_free);
+#endif
 	return NET_XMIT_DROP;
 }
 
@@ -1343,14 +1398,14 @@ static void nss_qdisc_set_hybrid_mode_ca
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_error("Qdisc %p (type %d): shaper node set default FAILED, response type: %d\n",
+		nss_qdisc_error("Qdisc %px (type %d): shaper node set default FAILED, response type: %d\n",
 			nq->qdisc, nq->type, nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_FAILED_RESPONSE);
 		wake_up(&nq->wait_queue);
 		return;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): attach complete\n", nq->qdisc, nq->type);
+	nss_qdisc_info("Qdisc %px (type %d): attach complete\n", nq->qdisc, nq->type);
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 	wake_up(&nq->wait_queue);
 }
@@ -1365,12 +1420,12 @@ int nss_qdisc_set_hybrid_mode(struct nss
 	int msg_type;
 	struct nss_if_msg nim;
 
-	nss_qdisc_info("Setting qdisc %p (type %d) as hybrid mode\n",
+	nss_qdisc_info("Setting qdisc %px (type %d) as hybrid mode\n",
 			nq->qdisc, nq->type);
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("Qdisc %p (type %d): qdisc state not ready: %d\n",
+		nss_qdisc_warning("Qdisc %px (type %d): qdisc state not ready: %d\n",
 				nq->qdisc, nq->type, state);
 		return -1;
 	}
@@ -1417,13 +1472,13 @@ int nss_qdisc_set_hybrid_mode(struct nss
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_error("Qdisc %p (type %d): failed to set hybrid mode "
+		nss_qdisc_error("Qdisc %px (type %d): failed to set hybrid mode "
 			"State: %d\n", nq->qdisc, nq->type, state);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): shaper node set hybrid mode complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): shaper node set hybrid mode complete\n",
 			nq->qdisc, nq->type);
 	return 0;
 }
@@ -1438,14 +1493,14 @@ static void nss_qdisc_set_default_callba
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_error("Qdisc %p (type %d): shaper node set default FAILED, response type: %d\n",
+		nss_qdisc_error("Qdisc %px (type %d): shaper node set default FAILED, response type: %d\n",
 			nq->qdisc, nq->type, nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_FAILED_RESPONSE);
 		wake_up(&nq->wait_queue);
 		return;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): attach complete\n", nq->qdisc, nq->type);
+	nss_qdisc_info("Qdisc %px (type %d): attach complete\n", nq->qdisc, nq->type);
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 	wake_up(&nq->wait_queue);
 }
@@ -1460,12 +1515,12 @@ int nss_qdisc_set_default(struct nss_qdi
 	int msg_type;
 	struct nss_if_msg nim;
 
-	nss_qdisc_info("Setting qdisc %p (type %d) as default\n",
+	nss_qdisc_info("Setting qdisc %px (type %d) as default\n",
 			nq->qdisc, nq->type);
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("Qdisc %p (type %d): qdisc state not ready: %d\n",
+		nss_qdisc_warning("Qdisc %px (type %d): qdisc state not ready: %d\n",
 				nq->qdisc, nq->type, state);
 		return -1;
 	}
@@ -1506,13 +1561,13 @@ int nss_qdisc_set_default(struct nss_qdi
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_error("Qdisc %p (type %d): failed to default "
+		nss_qdisc_error("Qdisc %px (type %d): failed to default "
 			"State: %d\n", nq->qdisc, nq->type, state);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): shaper node default complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): shaper node default complete\n",
 			nq->qdisc, nq->type);
 	return 0;
 }
@@ -1527,7 +1582,7 @@ static void nss_qdisc_node_attach_callba
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_info("Qdisc %p (type %d) shaper node attach FAILED - response "
+		nss_qdisc_info("Qdisc %px (type %d) shaper node attach FAILED - response "
 			"type: %d\n", nq->qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_FAILED_RESPONSE);
@@ -1535,7 +1590,7 @@ static void nss_qdisc_node_attach_callba
 		return;
 	}
 
-	nss_qdisc_info("qdisc type %d: %p, attach complete\n",
+	nss_qdisc_info("qdisc type %d: %px, attach complete\n",
 			nq->type, nq->qdisc);
 
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
@@ -1552,12 +1607,12 @@ int nss_qdisc_node_attach(struct nss_qdi
 	int32_t state, rc;
 	int msg_type;
 
-	nss_qdisc_info("Qdisc %p (type %d) attaching\n",
+	nss_qdisc_info("Qdisc %px (type %d) attaching\n",
 			nq->qdisc, nq->type);
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (nq->mode == NSS_QDISC_MODE_PPE) {
 		if (nss_ppe_node_attach(nq, nq_child) < 0) {
-			nss_qdisc_warning("attach of new qdisc %p failed\n", nq_child->qdisc);
+			nss_qdisc_warning("attach of new qdisc %px failed\n", nq_child->qdisc);
 			return -EINVAL;
 
 		}
@@ -1567,7 +1622,7 @@ int nss_qdisc_node_attach(struct nss_qdi
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("Qdisc %p (type %d): not ready, state: %d\n",
+		nss_qdisc_warning("Qdisc %px (type %d): not ready, state: %d\n",
 				nq->qdisc, nq->type, state);
 		return -1;
 	}
@@ -1607,7 +1662,7 @@ int nss_qdisc_node_attach(struct nss_qdi
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_error("Qdisc %p (type %d) failed to attach child "
+		nss_qdisc_error("Qdisc %px (type %d) failed to attach child "
 			"node, State: %d\n", nq->qdisc, nq->type, state);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
@@ -1620,7 +1675,15 @@ int nss_qdisc_node_attach(struct nss_qdi
 	nq_child->parent = nq;
 	spin_unlock_bh(&nq_child->lock);
 
-	nss_qdisc_info("Qdisc %p (type %d): shaper node attach complete\n",
+#if defined(NSS_QDISC_PPE_SUPPORT)
+	/*
+	 * In case of hybrid mode, enable PPE queues when NSS queuing
+	 * Qdiscs are attached in the hierarchy.
+	 */
+	nss_ppe_all_queue_enable_hybrid(nq_child);
+#endif
+
+	nss_qdisc_info("Qdisc %px (type %d): shaper node attach complete\n",
 			nq->qdisc, nq->type);
 	return 0;
 }
@@ -1635,7 +1698,7 @@ static void nss_qdisc_node_detach_callba
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_info("Qdisc %p (type %d): shaper node detach FAILED - response "
+		nss_qdisc_info("Qdisc %px (type %d): shaper node detach FAILED - response "
 			"type: %d\n", nq->qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_FAILED_RESPONSE);
@@ -1643,7 +1706,7 @@ static void nss_qdisc_node_detach_callba
 		return;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): detach complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): detach complete\n",
 			nq->qdisc, nq->type);
 
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
@@ -1659,13 +1722,13 @@ int nss_qdisc_node_detach(struct nss_qdi
 {
 	int32_t state, rc, msg_type;
 
-	nss_qdisc_info("Qdisc %p (type %d) detaching\n",
+	nss_qdisc_info("Qdisc %px (type %d) detaching\n",
 			nq->qdisc, nq->type);
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (nq->mode == NSS_QDISC_MODE_PPE) {
 		if (nss_ppe_node_detach(nq, nq_child) < 0) {
-			nss_qdisc_warning("detach of old qdisc %p failed\n", nq_child->qdisc);
+			nss_qdisc_warning("detach of old qdisc %px failed\n", nq_child->qdisc);
 			return -1;
 		}
 		nim->msg.shaper_configure.config.msg.shaper_node_config.snc.ppe_sn_detach.child_qos_tag = nq_child->qos_tag;
@@ -1674,7 +1737,7 @@ int nss_qdisc_node_detach(struct nss_qdi
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("Qdisc %p (type %d): not ready, state: %d\n",
+		nss_qdisc_warning("Qdisc %px (type %d): not ready, state: %d\n",
 				nq->qdisc, nq->type, state);
 		return -1;
 	}
@@ -1695,7 +1758,7 @@ int nss_qdisc_node_detach(struct nss_qdi
 	rc = nss_if_tx_msg(nq->nss_shaping_ctx, nim);
 
 	if (rc != NSS_TX_SUCCESS) {
-		nss_qdisc_warning("Qdisc %p (type %d): Failed to send configure "
+		nss_qdisc_warning("Qdisc %px (type %d): Failed to send configure "
 					"message.", nq->qdisc, nq->type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
@@ -1714,7 +1777,7 @@ int nss_qdisc_node_detach(struct nss_qdi
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_error("Qdisc %p (type %d): failed to detach child node, "
+		nss_qdisc_error("Qdisc %px (type %d): failed to detach child node, "
 				"State: %d\n", nq->qdisc, nq->type, state);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
@@ -1724,7 +1787,7 @@ int nss_qdisc_node_detach(struct nss_qdi
 	nq_child->parent = NULL;
 	spin_unlock_bh(&nq_child->lock);
 
-	nss_qdisc_info("Qdisc %p (type %d): shaper node detach complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): shaper node detach complete\n",
 			nq->qdisc, nq->type);
 	return 0;
 }
@@ -1739,7 +1802,7 @@ static void nss_qdisc_configure_callback
 	struct nss_qdisc *nq = (struct nss_qdisc *)app_data;
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_info("Qdisc %p (type %d): shaper node configure FAILED "
+		nss_qdisc_info("Qdisc %px (type %d): shaper node configure FAILED "
 			"response type: %d\n", nq->qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_FAILED_RESPONSE);
@@ -1755,7 +1818,7 @@ static void nss_qdisc_configure_callback
 		nq->config_cb(nq, &nim->msg.shaper_configure.config);
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): configuration complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): configuration complete\n",
 			nq->qdisc, nq->type);
 	atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 	wake_up(&nq->wait_queue);
@@ -1771,11 +1834,11 @@ int nss_qdisc_configure(struct nss_qdisc
 	int32_t state, rc;
 	int msg_type;
 
-	nss_qdisc_info("Qdisc %p (type %d) configuring\n", nq->qdisc, nq->type);
+	nss_qdisc_info("Qdisc %px (type %d) configuring\n", nq->qdisc, nq->type);
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("Qdisc %p (type %d): not ready for configure, "
+		nss_qdisc_warning("Qdisc %px (type %d): not ready for configure, "
 				"state : %d\n", nq->qdisc, nq->type, state);
 		return -1;
 	}
@@ -1796,7 +1859,7 @@ int nss_qdisc_configure(struct nss_qdisc
 	rc = nss_if_tx_msg(nq->nss_shaping_ctx, nim);
 
 	if (rc != NSS_TX_SUCCESS) {
-		nss_qdisc_warning("Qdisc %p (type %d): Failed to send configure "
+		nss_qdisc_warning("Qdisc %px (type %d): Failed to send configure "
 			"message\n", nq->qdisc, nq->type);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
@@ -1815,13 +1878,13 @@ int nss_qdisc_configure(struct nss_qdisc
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_error("Qdisc %p (type %d): failed to configure shaper "
+		nss_qdisc_error("Qdisc %px (type %d): failed to configure shaper "
 			"node: State: %d\n", nq->qdisc, nq->type, state);
 		atomic_set(&nq->state, NSS_QDISC_STATE_READY);
 		return -1;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): shaper node configure complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): shaper node configure complete\n",
 			nq->qdisc, nq->type);
 	return 0;
 }
@@ -1832,7 +1895,7 @@ int nss_qdisc_configure(struct nss_qdisc
  */
 void nss_qdisc_register_configure_callback(struct nss_qdisc *nq, nss_qdisc_configure_callback_t cb)
 {
-	nss_qdisc_assert(!nq->config_cb, "Qdisc %p: config callback already registered", nq);
+	nss_qdisc_assert(!nq->config_cb, "Qdisc %px: config callback already registered", nq);
 	nq->config_cb = cb;
 }
 
@@ -1842,7 +1905,7 @@ void nss_qdisc_register_configure_callba
  */
 void nss_qdisc_register_stats_callback(struct nss_qdisc *nq, nss_qdisc_stats_callback_t cb)
 {
-	nss_qdisc_assert(!nq->stats_cb, "Qdisc %p: config callback already registered", nq);
+	nss_qdisc_assert(!nq->stats_cb, "Qdisc %px: config callback already registered", nq);
 	nq->stats_cb = cb;
 }
 
@@ -1856,13 +1919,18 @@ void nss_qdisc_destroy(struct nss_qdisc
 	int32_t state;
 	nss_tx_status_t cmd_status;
 
-	nss_qdisc_info("Qdisc %p (type %d) destroy\n",
+	nss_qdisc_info("Qdisc %px (type %d) destroy\n",
 			nq->qdisc, nq->type);
 
 	/*
 	 * Destroy any attached filter over qdisc.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	tcf_destroy_chain(&nq->filter_list);
+#else
+	tcf_block_put(nq->block);
+#endif
+
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (nq->mode == NSS_QDISC_MODE_PPE) {
 		nss_ppe_destroy(nq);
@@ -1871,7 +1939,7 @@ void nss_qdisc_destroy(struct nss_qdisc
 
 	state = atomic_read(&nq->state);
 	if (state != NSS_QDISC_STATE_READY) {
-		nss_qdisc_warning("Qdisc %p (type %d): destroy not ready, "
+		nss_qdisc_warning("Qdisc %px (type %d): destroy not ready, "
 				"state: %d\n", nq->qdisc, nq->type, state);
 		return;
 	}
@@ -1880,14 +1948,16 @@ void nss_qdisc_destroy(struct nss_qdisc
 	 * How we begin to tidy up depends on whether we are root or child
 	 */
 	nq->pending_final_state = NSS_QDISC_STATE_IDLE;
-	if (nq->is_root) {
+	if (!nq->is_root) {
+		nss_qdisc_child_cleanup_free_node(nq);
+	} else {
 
 		/*
 		 * If this is root on a bridge interface, then unassign
 		 * the bshaper from all the attached interfaces.
 		 */
 		if (nq->is_bridge) {
-			nss_qdisc_info("Qdisc %p (type %d): is root on bridge. Need to "
+			nss_qdisc_info("Qdisc %px (type %d): is root on bridge. Need to "
 				"unassign bshapers from its interfaces\n", nq->qdisc, nq->type);
 			nss_qdisc_refresh_bshaper_assignment(nq->qdisc, NSS_QDISC_SCAN_AND_UNASSIGN_BSHAPER);
 		}
@@ -1897,8 +1967,12 @@ void nss_qdisc_destroy(struct nss_qdisc
 		 */
 		nss_qdisc_root_cleanup_free_node(nq);
 
-	} else {
-		nss_qdisc_child_cleanup_free_node(nq);
+		/*
+		 * In case of IGS interface, release the reference of the IGS module.
+		 */
+		if (nss_igs_verify_if_num(nq->nss_interface_number)) {
+			nss_igs_module_put();
+		}
 	}
 
 	/*
@@ -1923,23 +1997,30 @@ void nss_qdisc_destroy(struct nss_qdisc
 		 */
 		cmd_status = nss_virt_if_destroy_sync(nq->virt_if_ctx);
 		if (cmd_status != NSS_TX_SUCCESS) {
-			nss_qdisc_error("Qdisc %p virtual interface %p destroy failed: %d\n",
+			nss_qdisc_error("Qdisc %px virtual interface %px destroy failed: %d\n",
 						nq->qdisc, nq->virt_if_ctx, cmd_status);
 		}
 		nq->virt_if_ctx = NULL;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d): destroy complete\n",
+	nss_qdisc_info("Qdisc %px (type %d): destroy complete\n",
 			nq->qdisc, nq->type);
 }
 
 /*
- * nss_qdisc_init()
+ * __nss_qdisc_init()
  *	Initializes a shaper in NSS, based on the position of this qdisc (child or root)
  *	and if its a normal interface or a bridge interface.
  */
-int nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+int __nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode)
+{
+#else
+int __nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode,
+		struct netlink_ext_ack *extack)
 {
+	int err;
+#endif
 	struct Qdisc *root;
 	u32 parent;
 	nss_tx_status_t rc;
@@ -1951,9 +2032,9 @@ int nss_qdisc_init(struct Qdisc *sch, st
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	bool mode_ppe = false;
 #endif
-
+	bool igs_put = false;
 	if (accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-		nss_qdisc_warning("Qdisc %p (type %d) accel_mode:%u should be < %u\n",
+		nss_qdisc_warning("Qdisc %px (type %d) accel_mode:%u should be < %u\n",
 					sch, nq->type, accel_mode, TCA_NSS_ACCEL_MODE_MAX);
 		return -1;
 	}
@@ -2010,8 +2091,9 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	/*
 	 * Initialize filter list.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	RCU_INIT_POINTER(nq->filter_list, NULL);
-
+#endif
 	/*
 	 * If we are a class, then classid is used as the qos tag.
 	 * Else the qdisc handle will be used as the qos tag.
@@ -2032,11 +2114,11 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	 * true for classes. This is the reason why we check for classid.
 	 */
 	if ((sch->parent == TC_H_ROOT) && (!nq->is_class)) {
-		nss_qdisc_info("Qdisc %p (type %d) is root\n", nq->qdisc, nq->type);
+		nss_qdisc_info("Qdisc %px (type %d) is root\n", nq->qdisc, nq->type);
 		nq->is_root = true;
 		root = sch;
 	} else {
-		nss_qdisc_info("Qdisc %p (type %d) not root\n", nq->qdisc, nq->type);
+		nss_qdisc_info("Qdisc %px (type %d) not root\n", nq->qdisc, nq->type);
 		nq->is_root = false;
 		root = qdisc_root(sch);
 	}
@@ -2046,24 +2128,43 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	 * or on a net device that is represented by a virtual NSS interface (e.g. WIFI)
 	 */
 	dev = qdisc_dev(sch);
-	nss_qdisc_info("Qdisc %p (type %d) init dev: %p\n", nq->qdisc, nq->type, dev);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+	/*
+	 * Currently filter addition is only supported over IFB interfaces.
+	 * Therefore, perform tcf block allocation (which is used for storing
+	 * filter list) only if the input net device is an IFB device.
+	 */
+	if (netif_is_ifb_dev(dev)) {
+		err = tcf_block_get(&nq->block, &nq->filter_list, sch, extack);
+		if (err) {
+			nss_qdisc_error("%px: Unable to initialize tcf_block\n", &nq->block);
+			return -1;
+		}
+	} else {
+		RCU_INIT_POINTER(nq->filter_list, NULL);
+		nq->block = NULL;
+	}
+#endif
+
+	nss_qdisc_info("Qdisc %px (type %d) init dev: %px\n", nq->qdisc, nq->type, dev);
 
 	/*
 	 * Determine if dev is a bridge or not as this determines if we
 	 * interract with an I or B shaper.
 	 */
 	if (dev->priv_flags & IFF_EBRIDGE) {
-		nss_qdisc_info("Qdisc %p (type %d) init qdisc: %p, is bridge\n",
+		nss_qdisc_info("Qdisc %px (type %d) init qdisc: %px, is bridge\n",
 			nq->qdisc, nq->type, nq->qdisc);
 		nq->is_bridge = true;
 	} else {
-		nss_qdisc_info("Qdisc %p (type %d) init qdisc: %p, not bridge\n",
+		nss_qdisc_info("Qdisc %px (type %d) init qdisc: %px, not bridge\n",
 			nq->qdisc, nq->type, nq->qdisc);
 		nq->is_bridge = false;
 	}
 
-	nss_qdisc_info("Qdisc %p (type %d) init root: %p, qos tag: %x, "
-		"parent: %x rootid: %s owner: %p\n", nq->qdisc, nq->type, root,
+	nss_qdisc_info("Qdisc %px (type %d) init root: %px, qos tag: %x, "
+		"parent: %x rootid: %s owner: %px\n", nq->qdisc, nq->type, root,
 		nq->qos_tag, parent, root->ops->id, root->ops->owner);
 
 	/*
@@ -2071,7 +2172,9 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	 * This is to prevent mixing NSS and PPE qdisc with linux qdisc.
 	 */
 	if ((parent != TC_H_ROOT) && (root->ops->owner != THIS_MODULE)) {
-		nss_qdisc_warning("NSS qdisc %p (type %d) used along with non-nss qdiscs,"
+		nss_qdisc_warning("parent (%d) and TC_H_ROOT (%d))", parent, TC_H_ROOT);
+		nss_qdisc_warning("root->ops->owner (%px) and THIS_MODULE (%px))", root->ops->owner , THIS_MODULE);
+		nss_qdisc_warning("NSS qdisc %px (type %d) used along with non-nss qdiscs,"
 			" or the interface is currently down", nq->qdisc, nq->type);
 	}
 
@@ -2092,7 +2195,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	if (!nq->is_root) {
 		struct nss_if_msg nim_alloc;
 
-		nss_qdisc_info("Qdisc %p (type %d) initializing non-root qdisc\n",
+		nss_qdisc_info("Qdisc %px (type %d) initializing non-root qdisc\n",
 				nq->qdisc, nq->type);
 
 		/*
@@ -2103,7 +2206,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		 */
 		nq->nss_interface_number = nss_cmn_get_interface_number(nq->nss_shaping_ctx, dev);
 		if (nq->nss_interface_number < 0) {
-			nss_qdisc_error("Qdisc %p (type %d) net device unknown to "
+			nss_qdisc_error("Qdisc %px (type %d) net device unknown to "
 				"nss driver %s\n", nq->qdisc, nq->type, dev->name);
 			nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 			atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
@@ -2120,7 +2223,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		 * Try initializing PPE Qdisc first.
 		 */
 		if (mode_ppe && nss_qdisc_ppe_init(sch, nq, type, parent) < 0) {
-			nss_qdisc_error("Qdisc %p (type %d) init failed", nq->qdisc, nq->type);
+			nss_qdisc_error("Qdisc %px (type %d) init failed", nq->qdisc, nq->type);
 			nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 			atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
 			goto init_fail;
@@ -2131,7 +2234,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		 * Create a shaper node for requested type.
 		 * Essentially all we need to do is create the shaper node.
 		 */
-		nss_qdisc_info("Qdisc %p (type %d) non-root (child) create\n",
+		nss_qdisc_info("Qdisc %px (type %d) non-root (child) create\n",
 				nq->qdisc, nq->type);
 
 		/*
@@ -2147,7 +2250,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		rc = nss_if_tx_msg(nq->nss_shaping_ctx, &nim_alloc);
 
 		if (rc != NSS_TX_SUCCESS) {
-			nss_qdisc_error("Qdisc %p (type %d) create command "
+			nss_qdisc_error("Qdisc %px (type %d) create command "
 				"failed: %d\n", nq->qdisc, nq->type, rc);
 			nq->pending_final_state = NSS_QDISC_STATE_CHILD_ALLOC_SEND_FAIL;
 			nss_qdisc_child_cleanup_final(nq);
@@ -2164,7 +2267,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		}
 
 		state = atomic_read(&nq->state);
-		nss_qdisc_info("Qdisc %p (type %d): initialised with state: %d\n",
+		nss_qdisc_info("Qdisc %px (type %d): initialised with state: %d\n",
 					nq->qdisc, nq->type, state);
 
 		/*
@@ -2184,13 +2287,13 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	 * bridge shaping. Further, when operating on a bridge, we monitor for
 	 * bridge port changes and assign B shapers to the interfaces of the ports.
 	 */
-	nss_qdisc_info("init qdisc type %d : %p, ROOT\n", nq->type, nq->qdisc);
+	nss_qdisc_info("init qdisc type %d : %px, ROOT\n", nq->type, nq->qdisc);
 
 	/*
 	 * Detect if we are operating on a bridge or interface
 	 */
 	if (nq->is_bridge) {
-		nss_qdisc_info("Qdisc %p (type %d): initializing root qdisc on bridge\n",
+		nss_qdisc_info("Qdisc %px (type %d): initializing root qdisc on bridge\n",
 			nq->qdisc, nq->type);
 
 		/*
@@ -2208,13 +2311,13 @@ int nss_qdisc_init(struct Qdisc *sch, st
 			 */
 			nq->virt_if_ctx = nss_virt_if_create_sync(dev);
 			if (!nq->virt_if_ctx) {
-				nss_qdisc_error("Qdisc %p (type %d): cannot create virtual interface\n",
+				nss_qdisc_error("Qdisc %px (type %d): cannot create virtual interface\n",
 					nq->qdisc, nq->type);
 				nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 				atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
 				goto init_fail;
 			}
-			nss_qdisc_info("Qdisc %p (type %d): virtual interface registered in NSS: %p\n",
+			nss_qdisc_info("Qdisc %px (type %d): virtual interface registered in NSS: %px\n",
 				nq->qdisc, nq->type, nq->virt_if_ctx);
 
 			/*
@@ -2227,7 +2330,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 			 * Save the virtual interface number
 			 */
 			nq->nss_interface_number = nss_virt_if_get_interface_num(nq->virt_if_ctx);
-			nss_qdisc_info("Qdisc %p (type %d) virtual interface number: %d\n",
+			nss_qdisc_info("Qdisc %px (type %d) virtual interface number: %d\n",
 					nq->qdisc, nq->type, nq->nss_interface_number);
 		}
 
@@ -2238,19 +2341,19 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		 * register for bridge bouncing as it will be responsible for
 		 * bouncing packets to the NSS for bridge shaping.
 		 */
-		if (nss_igs_verify_if_num(nq->nss_interface_number)) {
+		if (!nss_igs_verify_if_num(nq->nss_interface_number)) {
+			nq->bounce_context = nss_shaper_register_shaper_bounce_bridge(nq->nss_interface_number,
+					nss_qdisc_bounce_callback, nq->qdisc, THIS_MODULE);
+		} else {
 			nss_qdisc_error("Since %d is an IFB device, it cannot"
 					" register for bridge bouncing\n", nq->nss_interface_number);
 			nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 			atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
 			goto init_fail;
-		} else {
-			nq->bounce_context = nss_shaper_register_shaper_bounce_bridge(nq->nss_interface_number,
-					nss_qdisc_bounce_callback, nq->qdisc, THIS_MODULE);
 		}
 
 		if (!nq->bounce_context) {
-			nss_qdisc_error("Qdisc %p (type %d): is root but cannot register "
+			nss_qdisc_error("Qdisc %px (type %d): is root but cannot register "
 					"for bridge bouncing\n", nq->qdisc, nq->type);
 			nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 			atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
@@ -2258,7 +2361,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		}
 
 	} else {
-		nss_qdisc_info("Qdisc %p (type %d): is interface\n", nq->qdisc, nq->type);
+		nss_qdisc_info("Qdisc %px (type %d): is interface\n", nq->qdisc, nq->type);
 
 		/*
 		 * The device we are operational on MUST be recognised as an NSS interface.
@@ -2268,7 +2371,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		 */
 		nq->nss_interface_number = nss_cmn_get_interface_number(nq->nss_shaping_ctx, dev);
 		if (nq->nss_interface_number < 0) {
-			nss_qdisc_error("Qdisc %p (type %d): interface unknown to nss driver %s\n",
+			nss_qdisc_error("Qdisc %px (type %d): interface unknown to nss driver %s\n",
 					nq->qdisc, nq->type, dev->name);
 			nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 			atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
@@ -2281,25 +2384,44 @@ int nss_qdisc_init(struct Qdisc *sch, st
 		 */
 		nq->is_virtual = nss_qdisc_interface_is_virtual(nq->nss_shaping_ctx, nq->nss_interface_number);
 		if (!nq->is_virtual) {
-			nss_qdisc_info("Qdisc %p (type %d): interface %u is physical\n",
+			nss_qdisc_info("Qdisc %px (type %d): interface %u is physical\n",
 					nq->qdisc, nq->type, nq->nss_interface_number);
 		} else {
-			nss_qdisc_info("Qdisc %p (type %d): interface %u is virtual\n",
+			nss_qdisc_info("Qdisc %px (type %d): interface %u is virtual\n",
 					nq->qdisc, nq->type, nq->nss_interface_number);
 
 			/*
 			 * Register for interface bounce shaping.
 			 */
-			if (nss_igs_verify_if_num(nq->nss_interface_number)) {
+			if (!nss_igs_verify_if_num(nq->nss_interface_number)) {
 				nq->bounce_context = nss_shaper_register_shaper_bounce_interface(nq->nss_interface_number,
-						nss_qdisc_mark_and_schedule, nq->qdisc, THIS_MODULE);
+						nss_qdisc_bounce_callback, nq->qdisc, THIS_MODULE);
 			} else {
+
+				/*
+				 * In case of IGS interface, take the reference of IGS module.
+				 */
+				if (!nss_igs_module_get()) {
+					nss_qdisc_error("Module reference failed for IGS interface %d"
+							" , Qdisc %px (type %d)\n", nq->nss_interface_number,
+							nq->qdisc, nq->type);
+					nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
+					atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
+					goto init_fail;
+				}
+
+				/*
+				 * Set the flag to indicate the IGS module reference get is successful.
+				 * This flag will be used to decrement the IGS module reference in case
+				 * of any error conditions.
+				 */
+				igs_put = true;
 				nq->bounce_context = nss_shaper_register_shaper_bounce_interface(nq->nss_interface_number,
-						nss_qdisc_bounce_callback, nq->qdisc, THIS_MODULE);
+						nss_qdisc_mark_and_schedule, nq->qdisc, THIS_MODULE);
 			}
 
 			if (!nq->bounce_context) {
-				nss_qdisc_error("Qdisc %p (type %d): is root but failed "
+				nss_qdisc_error("Qdisc %px (type %d): is root but failed "
 				"to register for interface bouncing\n", nq->qdisc, nq->type);
 				nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 				atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
@@ -2313,7 +2435,7 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	 * Try initializing PPE Qdisc first.
 	 */
 	if (mode_ppe && nss_qdisc_ppe_init(sch, nq, type, parent) < 0) {
-		nss_qdisc_error("Qdisc %p (type %d) init failed", nq->qdisc, nq->type);
+		nss_qdisc_error("Qdisc %px (type %d) init failed", nq->qdisc, nq->type);
 		nss_shaper_unregister_shaping(nq->nss_shaping_ctx);
 		atomic_set(&nq->state, NSS_QDISC_STATE_INIT_FAILED);
 		goto init_fail;
@@ -2342,12 +2464,18 @@ int nss_qdisc_init(struct Qdisc *sch, st
 	 */
 	if (!wait_event_timeout(nq->wait_queue, atomic_read(&nq->state) != NSS_QDISC_STATE_IDLE,
 				NSS_QDISC_COMMAND_TIMEOUT)) {
-		nss_qdisc_error("init for qdisc %x timedout!\n", nq->qos_tag);
+		/*
+		 * Decrement the IGS module reference.
+		 */
+		if (igs_put) {
+			nss_igs_module_put();
+		}
+	nss_qdisc_error("init for qdisc %x timedout!\n", nq->qos_tag);
 		return -1;
 	}
 
 	state = atomic_read(&nq->state);
-	nss_qdisc_info("Qdisc %p (type %d): is initialised with state: %d\n",
+	nss_qdisc_info("Qdisc %px (type %d): is initialised with state: %d\n",
 			nq->qdisc, nq->type, state);
 
 	if (state > 0) {
@@ -2380,6 +2508,13 @@ int nss_qdisc_init(struct Qdisc *sch, st
 
 init_fail:
 
+	/*
+	 * Decrement the IGS module reference.
+	 */
+	if (igs_put) {
+		nss_igs_module_put();
+	}
+
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (nq->mode == NSS_QDISC_MODE_PPE) {
 		nss_ppe_destroy(nq);
@@ -2396,7 +2531,7 @@ init_fail:
 		 */
 		cmd_status = nss_virt_if_destroy_sync(nq->virt_if_ctx);
 		if (cmd_status != NSS_TX_SUCCESS) {
-			nss_qdisc_error("Qdisc %p virtual interface %p destroy failed: %d\n",
+			nss_qdisc_error("Qdisc %px virtual interface %px destroy failed: %d\n",
 						nq->qdisc, nq->virt_if_ctx, cmd_status);
 		}
 		nq->virt_if_ctx = NULL;
@@ -2406,6 +2541,20 @@ init_fail:
 }
 
 /*
+ * nss_qdisc_init()
+ *	Initialize nss qdisc based on position of the qdisc
+ */
+int nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid,
+		uint32_t accel_mode, void *extack)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+	return __nss_qdisc_init(sch, nq, type, classid, accel_mode);
+#else
+	return __nss_qdisc_init(sch, nq, type, classid, accel_mode, extack);
+#endif
+}
+
+/*
  * nss_qdisc_basic_stats_callback()
  *	Invoked after getting basic stats
  */
@@ -2417,10 +2566,14 @@ static void nss_qdisc_basic_stats_callba
 	struct gnet_stats_basic_packed *bstats;
 	struct gnet_stats_queue *qstats;
 	struct nss_shaper_node_stats_response *response;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
 	atomic_t *refcnt;
+#else
+	refcount_t *refcnt;
+#endif
 
 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_qdisc_warning("Qdisc %p (type %d): Receive stats FAILED - "
+		nss_qdisc_warning("Qdisc %px (type %d): Receive stats FAILED - "
 			"response: type: %d\n", qdisc, nq->type,
 			nim->msg.shaper_configure.config.response_type);
 		atomic_sub(1, &nq->pending_stat_requests);
@@ -2480,7 +2633,11 @@ static void nss_qdisc_basic_stats_callba
 	 * All access to nq fields below do not need lock protection. They
 	 * do not get manipulated on different thread contexts.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
 	if (atomic_read(refcnt) == 0) {
+#else
+	if (refcount_read(refcnt) == 0) {
+#endif
 		atomic_sub(1, &nq->pending_stat_requests);
 		wake_up(&nq->wait_queue);
 		return;
@@ -2502,9 +2659,18 @@ static void nss_qdisc_basic_stats_callba
  * nss_qdisc_get_stats_timer_callback()
  *	Invoked periodically to get updated stats
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
 static void nss_qdisc_get_stats_timer_callback(unsigned long int data)
+#else
+static void nss_qdisc_get_stats_timer_callback(struct timer_list *tm)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
 	struct nss_qdisc *nq = (struct nss_qdisc *)data;
+#else
+	struct nss_qdisc *nq = from_timer(nq, tm, stats_get_timer);
+#endif
+
 	nss_tx_status_t rc;
 	struct nss_if_msg nim;
 	int msg_type;
@@ -2524,7 +2690,7 @@ static void nss_qdisc_get_stats_timer_ca
 	 * Check if we failed to send the stats request to NSS.
 	 */
 	if (rc != NSS_TX_SUCCESS) {
-		nss_qdisc_info("%p: stats fetch request dropped, causing "
+		nss_qdisc_info("%px: stats fetch request dropped, causing "
 				"delay in stats fetch\n", nq->qdisc);
 
 		/*
@@ -2551,9 +2717,14 @@ void nss_qdisc_start_basic_stats_polling
 		return;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
 	init_timer(&nq->stats_get_timer);
 	nq->stats_get_timer.function = nss_qdisc_get_stats_timer_callback;
 	nq->stats_get_timer.data = (unsigned long)nq;
+#else
+	timer_setup(&nq->stats_get_timer, nss_qdisc_get_stats_timer_callback, 0);
+#endif
+
 	nq->stats_get_timer.expires = jiffies + HZ;
 	atomic_set(&nq->pending_stat_requests, 1);
 	add_timer(&nq->stats_get_timer);
@@ -2591,13 +2762,15 @@ void nss_qdisc_stop_basic_stats_polling(
  * nss_qdisc_gnet_stats_copy_basic()
  *  Wrapper around gnet_stats_copy_basic()
  */
-int nss_qdisc_gnet_stats_copy_basic(struct gnet_dump *d,
+int nss_qdisc_gnet_stats_copy_basic(struct Qdisc *sch, struct gnet_dump *d,
 				struct gnet_stats_basic_packed *b)
 {
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0))
 	return gnet_stats_copy_basic(d, b);
-#else
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return gnet_stats_copy_basic(d, NULL, b);
+#else
+	return gnet_stats_copy_basic(qdisc_root_sleeping_running(sch), d, NULL, b);
 #endif
 }
 
@@ -2636,10 +2809,8 @@ static int nss_qdisc_if_event_cb(struct
 
 	switch (event) {
 	case NETDEV_BR_JOIN:
-		nss_qdisc_info("Reveived NETDEV_BR_JOIN on interface %s\n",
-				dev->name);
 	case NETDEV_BR_LEAVE:
-		nss_qdisc_info("Reveived NETDEV_BR_LEAVE on interface %s\n",
+		nss_qdisc_info("Received NETDEV_BR_JOIN/NETDEV_BR_LEAVE on interface %s\n",
 				dev->name);
 		br = nss_qdisc_get_dev_master(dev);
 		if_num = nss_cmn_get_interface_number(nss_qdisc_ctx, dev);
@@ -2695,6 +2866,7 @@ static int nss_qdisc_if_event_cb(struct
 	return NOTIFY_DONE;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 /*
  * nss_qdisc_tcf_chain()
  *	Return the filter list of qdisc.
@@ -2719,8 +2891,29 @@ struct tcf_proto __rcu **nss_qdisc_tcf_c
 	if (nq->is_root) {
 		return &(nq->filter_list);
 	}
+
 	return NULL;
 }
+#else
+/*
+ * nss_qdisc_tcf_block()
+ *	Return the block containing chain of qdisc.
+ */
+struct tcf_block *nss_qdisc_tcf_block(struct Qdisc *sch, unsigned long cl, struct netlink_ext_ack *extack)
+{
+	struct nss_qdisc *nq = qdisc_priv(sch);
+
+	/*
+	 * Currently, support is available only for tc filter iterations
+	 * at root qdisc.
+	 */
+	if (nq->is_root) {
+		return nq->block;
+	}
+
+	return NULL;
+}
+#endif
 
 /*
  * nss_qdisc_tcf_bind()
--- a/nss_qdisc/nss_qdisc.h
+++ b/nss_qdisc/nss_qdisc.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2018 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2018, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/skbuff.h>
 #include <net/pkt_sched.h>
+#include <net/pkt_cls.h>
 #include <net/inet_ecn.h>
 #include <net/netfilter/nf_conntrack.h>
 #include <linux/if_bridge.h>
@@ -27,6 +28,9 @@
 #include <linux/version.h>
 #include <br_private.h>
 #include <nss_api_if.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+#include <linux/netlink.h>
+#endif
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
 #include "nss_ppe.h"
@@ -145,6 +149,7 @@ struct nss_qdisc {
 						 * the NSS e.g. perhaps operating on a wifi interface
 						 * or bridge.
 						 */
+	bool needs_ppe_loopback;		/* True when qdisc is on bridge or igs */
 	bool destroy_virtual_interface;		/* Set if the interface is first registered in NSS by
 						 * us. This means it needs to be un-regisreted when the
 						 * module goes down.
@@ -185,7 +190,11 @@ struct nss_qdisc {
 						 */
 	struct gnet_stats_basic_packed bstats;	/* Basic class statistics */
 	struct gnet_stats_queue qstats;		/* Qstats for use by classes */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
 	atomic_t refcnt;			/* Reference count for class use */
+#else
+	refcount_t refcnt;			/* Reference count for class use */
+#endif
 	struct timer_list stats_get_timer;	/* Timer used to poll for stats */
 	atomic_t pending_stat_requests;		/* Number of pending stats responses */
 	wait_queue_head_t wait_queue;		/* Wait queue used to wait on responses from the NSS */
@@ -200,6 +209,9 @@ struct nss_qdisc {
 						 */
 #endif
 	struct tcf_proto __rcu *filter_list;	/* Filter list */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
+	struct tcf_block *block;
+#endif
 };
 
 /*
@@ -237,11 +249,81 @@ enum nss_qdisc_hybrid_mode {
 };
 
 /*
+ * nss_qdisc_nla_nest_start()
+ *	Returns the container attribute
+ */
+static inline struct nlattr * nss_qdisc_nla_nest_start(struct sk_buff *skb, int attrtype)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
+	return nla_nest_start(skb, TCA_OPTIONS);
+#else
+	return nla_nest_start_noflag(skb, TCA_OPTIONS);
+#endif
+}
+
+/*
+ * nss_qdisc_atomic_sub()
+ *	Atomically decrements the ref count by 1
+ */
+static inline void nss_qdisc_atomic_sub(struct nss_qdisc *nq)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
+	atomic_sub(1, &nq->refcnt);
+#else
+	atomic_sub(1, &nq->refcnt.refs);
+#endif
+}
+
+/*
+ * nss_qdisc_atomic_sub_return()
+ *	Atomically decrements the ref count by 1 and return ref count
+ */
+static inline int nss_qdisc_atomic_sub_return(struct nss_qdisc *nq)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
+	return atomic_sub_return(1, &nq->refcnt);
+#else
+	return atomic_sub_return(1, &nq->refcnt.refs);
+#endif
+}
+
+/*
+ * nss_qdisc_atomic_set()
+ *	Atomically sets the ref count by 1
+ */
+static inline void nss_qdisc_atomic_set(struct nss_qdisc *nq)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0))
+	atomic_set(&nq->refcnt, 1);
+#else
+	refcount_set(&nq->refcnt, 1);
+#endif
+}
+
+/*
+ * nss_qdisc_put()
+ *	Destroy the qdisc
+ */
+static inline void nss_qdisc_put(struct Qdisc *sch)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
+	qdisc_destroy(sch);
+#else
+	qdisc_put(sch);
+#endif
+}
+
+/*
  * nss_qdisc_qopt_get()
  *	Extracts qopt from opt.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 extern void *nss_qdisc_qopt_get(struct nlattr *opt, struct nla_policy *policy,
-				uint32_t tca_max, uint32_t tca_params);
+				struct nlattr *tb[], uint32_t tca_max, uint32_t tca_params);
+#else
+extern void *nss_qdisc_qopt_get(struct nlattr *opt, struct nla_policy *policy,
+				struct nlattr *tb[], uint32_t tca_max, uint32_t tca_params, struct netlink_ext_ack *extack);
+#endif
 
 /*
  * nss_qdisc_mode_get()
@@ -255,11 +337,13 @@ extern uint8_t nss_qdisc_accel_mode_get(
  */
 extern struct sk_buff *nss_qdisc_peek(struct Qdisc *sch);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_qdisc_drop()
  *	Called to drop the packet at the head of queue
  */
 extern unsigned int nss_qdisc_drop(struct Qdisc *sch);
+#endif
 
 /*
  * nss_qdisc_reset()
@@ -271,7 +355,11 @@ extern void nss_qdisc_reset(struct Qdisc
  * nss_qdisc_enqueue()
  *	Generic enqueue call for enqueuing packets into NSS for shaping
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 extern int nss_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch);
+#else
+extern int nss_qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free);
+#endif
 
 /*
  * nss_qdisc_dequeue()
@@ -337,7 +425,8 @@ extern void nss_qdisc_destroy(struct nss
  *	Initializes a shaper in NSS, based on the position of this qdisc (child or root)
  *	and if its a normal interface or a bridge interface.
  */
-extern int nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode);
+extern int nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode,
+		void *extack);
 
 /*
  * nss_qdisc_start_basic_stats_polling()
@@ -355,8 +444,8 @@ extern void nss_qdisc_stop_basic_stats_p
  * nss_qdisc_gnet_stats_copy_basic()
  *  Wrapper around gnet_stats_copy_basic()
  */
-extern int nss_qdisc_gnet_stats_copy_basic(struct gnet_dump *d,
-				struct gnet_stats_basic_packed *b);
+extern int nss_qdisc_gnet_stats_copy_basic(struct Qdisc *sch,
+				struct gnet_dump *d, struct gnet_stats_basic_packed *b);
 
 /*
  * nss_qdisc_gnet_stats_copy_queue()
@@ -372,11 +461,19 @@ extern int nss_qdisc_gnet_stats_copy_que
 extern struct Qdisc *nss_qdisc_replace(struct Qdisc *sch, struct Qdisc *new,
 					struct Qdisc **pold);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 /*
  * nss_qdisc_tcf_chain()
  *	Return the filter list of qdisc.
  */
 extern struct tcf_proto __rcu **nss_qdisc_tcf_chain(struct Qdisc *sch, unsigned long arg);
+#else
+/*
+ * nss_qdisc_tcf_block()
+ *	Return the block containing chain of qdisc.
+ */
+extern struct tcf_block *nss_qdisc_tcf_block(struct Qdisc *sch, unsigned long cl, struct netlink_ext_ack *extack);
+#endif
 
 /*
  * nss_qdisc_tcf_bind()
--- a/nss_qdisc/nss_tbl.c
+++ b/nss_qdisc/nss_tbl.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -29,9 +29,18 @@ static struct nla_policy nss_tbl_policy[
 	[TCA_NSSTBL_PARMS] = { .len = sizeof(struct tc_nsstbl_qopt) },
 };
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_tbl_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_tbl_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 static struct sk_buff *nss_tbl_dequeue(struct Qdisc *sch)
@@ -39,10 +48,12 @@ static struct sk_buff *nss_tbl_dequeue(s
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static unsigned int nss_tbl_drop(struct Qdisc *sch)
 {
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 static struct sk_buff *nss_tbl_peek(struct Qdisc *sch)
 {
@@ -77,7 +88,7 @@ static void nss_tbl_destroy(struct Qdisc
 	/*
 	 * Now we can destroy our child qdisc
 	 */
-	qdisc_destroy(q->qdisc);
+	 nss_qdisc_put(q->qdisc);
 
 	/*
 	 * Stop the polling of basic stats and destroy qdisc.
@@ -87,7 +98,11 @@ static void nss_tbl_destroy(struct Qdisc
 }
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_tbl_ppe_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_tbl_ppe_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
 	struct nss_qdisc *nq = &q->nq;
@@ -123,8 +138,12 @@ fail:
 	/*
 	 * PPE qdisc config failed, try to initialize in NSS.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_ppe_fallback_to_nss(nq, opt)) {
-		nss_qdisc_warning("nss_tbl %x fallback to nss failed\n", sch->handle);
+#else
+	if (nss_ppe_fallback_to_nss(nq, opt, extack)) {
+#endif
+	nss_qdisc_warning("nss_tbl %x fallback to nss failed\n", sch->handle);
 		return -EINVAL;
 	}
 
@@ -132,9 +151,15 @@ fail:
 }
 #endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_tbl_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_tbl_change(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSTBL_MAX + 1];
 	struct tc_nsstbl_qopt *qopt;
 	struct nss_if_msg nim;
 	struct net_device *dev = qdisc_dev(sch);
@@ -143,7 +168,11 @@ static int nss_tbl_change(struct Qdisc *
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_tbl_policy, TCA_NSSTBL_MAX, TCA_NSSTBL_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_tbl_policy, tb, TCA_NSSTBL_MAX, TCA_NSSTBL_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_tbl_policy, tb, TCA_NSSTBL_MAX, TCA_NSSTBL_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -178,7 +207,11 @@ static int nss_tbl_change(struct Qdisc *
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (q->nq.mode == NSS_QDISC_MODE_PPE) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 		if (nss_tbl_ppe_change(sch, opt) < 0) {
+#else
+		if (nss_tbl_ppe_change(sch, opt, extack) < 0) {
+#endif
 			nss_qdisc_warning("nss_tbl %x SSDK scheduler config failed\n", sch->handle);
 			return -EINVAL;
 		}
@@ -216,9 +249,17 @@ static int nss_tbl_change(struct Qdisc *
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_tbl_init(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_tbl_init(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSTBL_MAX + 1];
 	struct tc_nsstbl_qopt *qopt;
 
 	if (!opt) {
@@ -227,15 +268,25 @@ static int nss_tbl_init(struct Qdisc *sc
 
 	q->qdisc = &noop_qdisc;
 
-	qopt = nss_qdisc_qopt_get(opt, nss_tbl_policy, TCA_NSSTBL_MAX, TCA_NSSTBL_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_tbl_policy, tb, TCA_NSSTBL_MAX, TCA_NSSTBL_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_tbl_policy, tb, TCA_NSSTBL_MAX, TCA_NSSTBL_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
 
-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_TBL, 0, qopt->accel_mode) < 0)
+	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_TBL, 0, qopt->accel_mode, extack) < 0)
+	{
 		return -EINVAL;
+	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_tbl_change(sch, opt) < 0) {
+#else
+	if (nss_tbl_change(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_info("Failed to configure tbl\n");
 		nss_qdisc_destroy(&q->nq);
 		return -EINVAL;
@@ -262,7 +313,8 @@ static int nss_tbl_dump(struct Qdisc *sc
 	opt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
 	nss_qdisc_info("Nsstbl dumping");
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL || nla_put(skb, TCA_NSSTBL_PARMS, sizeof(opt), &opt)) {
 		goto nla_put_failure;
 	}
@@ -286,8 +338,13 @@ static int nss_tbl_dump_class(struct Qdi
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_tbl_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
 			struct Qdisc **old)
+#else
+static int nss_tbl_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
+			struct Qdisc **old, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
 	struct nss_qdisc *nq_new = (struct nss_qdisc *)qdisc_priv(new);
@@ -301,10 +358,10 @@ static int nss_tbl_graft(struct Qdisc *s
 	*old = q->qdisc;
 	sch_tree_unlock(sch);
 
-	nss_qdisc_info("Grafting old: %p with new: %p\n", *old, new);
+	nss_qdisc_info("Grafting old: %px with new: %px\n", *old, new);
 	if (*old != &noop_qdisc) {
 		struct nss_qdisc *nq_old = (struct nss_qdisc *)qdisc_priv(*old);
-		nss_qdisc_info("Detaching old: %p\n", *old);
+		nss_qdisc_info("Detaching old: %px\n", *old);
 		nim_detach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = q->nq.qos_tag;
 		if (nss_qdisc_node_detach(&q->nq, nq_old, &nim_detach,
 				NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_DETACH) < 0) {
@@ -313,7 +370,7 @@ static int nss_tbl_graft(struct Qdisc *s
 	}
 
 	if (new != &noop_qdisc) {
-		nss_qdisc_info("Attaching new: %p\n", new);
+		nss_qdisc_info("Attaching new: %px\n", new);
 		nim_attach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = q->nq.qos_tag;
 		nim_attach.msg.shaper_configure.config.msg.shaper_node_config.snc.tbl_attach.child_qos_tag = nq_new->qos_tag;
 		if (nss_qdisc_node_attach(&q->nq, nq_new, &nim_attach,
@@ -339,6 +396,7 @@ static struct Qdisc *nss_tbl_leaf(struct
 	return q->qdisc;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 static unsigned long nss_tbl_get(struct Qdisc *sch, u32 classid)
 {
 	return 1;
@@ -347,6 +405,12 @@ static unsigned long nss_tbl_get(struct
 static void nss_tbl_put(struct Qdisc *sch, unsigned long arg)
 {
 }
+#else
+static unsigned long nss_tbl_search(struct Qdisc *sch, u32 classid)
+{
+	return 1;
+}
+#endif
 
 static void nss_tbl_walk(struct Qdisc *sch, struct qdisc_walker *walker)
 {
@@ -364,9 +428,17 @@ static void nss_tbl_walk(struct Qdisc *s
 const struct Qdisc_class_ops nss_tbl_class_ops = {
 	.graft		=	nss_tbl_graft,
 	.leaf		=	nss_tbl_leaf,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	.get		=	nss_tbl_get,
 	.put		=	nss_tbl_put,
+#else
+	.find       =   nss_tbl_search,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	.tcf_chain	=	nss_qdisc_tcf_chain,
+#else
+	.tcf_block	=	nss_qdisc_tcf_block,
+#endif
 	.bind_tcf	=	nss_qdisc_tcf_bind,
 	.unbind_tcf	=	nss_qdisc_tcf_unbind,
 	.walk		=	nss_tbl_walk,
@@ -381,7 +453,9 @@ struct Qdisc_ops nss_tbl_qdisc_ops __rea
 	.enqueue	=	nss_tbl_enqueue,
 	.dequeue	=	nss_tbl_dequeue,
 	.peek		=	nss_tbl_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_tbl_drop,
+#endif
 	.init		=	nss_tbl_init,
 	.reset		=	nss_tbl_reset,
 	.destroy	=	nss_tbl_destroy,
@@ -389,4 +463,3 @@ struct Qdisc_ops nss_tbl_qdisc_ops __rea
 	.dump		=	nss_tbl_dump,
 	.owner		=	THIS_MODULE,
 };
-
--- a/nss_qdisc/nss_wred.c
+++ b/nss_qdisc/nss_wred.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -55,9 +55,18 @@ static struct nla_policy nss_wred_policy
  * nss_wred_enqueue()
  *	Enqueue API for nsswred qdisc
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_wred_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_wred_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 /*
@@ -69,6 +78,7 @@ static struct sk_buff *nss_wred_dequeue(
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 /*
  * nss_wred_drop()
  *	Drops a packet from HLOS queue.
@@ -78,6 +88,7 @@ static unsigned int nss_wred_drop(struct
 	nss_qdisc_info("nsswred dropping");
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 /*
  * nss_wred_reset()
@@ -111,7 +122,11 @@ static void nss_wred_destroy(struct Qdis
  * nss_wred_ppe_change()
  *	Function call to configure the nssred parameters for ppe qdisc.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wred_ppe_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_wred_ppe_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_wred_sched_data *q = qdisc_priv(sch);
 	struct nss_qdisc *nq = &q->nq;
@@ -159,8 +174,12 @@ fail:
 	/*
 	 * Fallback to nss qdisc if PPE Qdisc configuration failed at init time.
 	 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_ppe_fallback_to_nss(&q->nq, opt) < 0) {
-		nss_qdisc_warning("nss_wred %x fallback to nss failed\n", sch->handle);
+#else
+	if (nss_ppe_fallback_to_nss(&q->nq, opt, extack) < 0) {
+#endif
+	nss_qdisc_warning("nss_wred %x fallback to nss failed\n", sch->handle);
 		return -EINVAL;
 	}
 	return 0;
@@ -171,9 +190,15 @@ fail:
  * nss_wred_change()
  *	Function call to configure the nsswred parameters
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wred_change(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_wred_change(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_wred_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSWRED_MAX + 1];
 	struct tc_nsswred_qopt *qopt;
 	struct nss_if_msg nim;
 
@@ -181,7 +206,11 @@ static int nss_wred_change(struct Qdisc
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_wred_policy, TCA_NSSWRED_MAX, TCA_NSSWRED_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_wred_policy, tb, TCA_NSSWRED_MAX, TCA_NSSWRED_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_wred_policy, tb, TCA_NSSWRED_MAX, TCA_NSSWRED_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -253,8 +282,12 @@ static int nss_wred_change(struct Qdisc
 
 #if defined(NSS_QDISC_PPE_SUPPORT)
 	if (q->nq.mode == NSS_QDISC_MODE_PPE) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 		if (nss_wred_ppe_change(sch, opt) < 0) {
-			nss_qdisc_warning("nss_wred %p params validate and save failed\n", sch);
+#else
+		if (nss_wred_ppe_change(sch, opt, extack) < 0) {
+#endif
+			nss_qdisc_warning("nss_wred %px params validate and save failed\n", sch);
 			return -EINVAL;
 		}
 		return 0;
@@ -298,16 +331,28 @@ static int nss_wred_change(struct Qdisc
  * nss_wred_init()
  *	Init the nsswred qdisc
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wred_init(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_wred_init(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_qdisc *nq = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSWRED_MAX + 1];
 	struct tc_nsswred_qopt *qopt;
 
 	if (opt == NULL) {
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_wred_policy, TCA_NSSWRED_MAX, TCA_NSSWRED_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_wred_policy, tb, TCA_NSSWRED_MAX, TCA_NSSWRED_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_wred_policy, tb, TCA_NSSWRED_MAX, TCA_NSSWRED_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -315,11 +360,17 @@ static int nss_wred_init(struct Qdisc *s
 	nss_qdisc_info("Initializing Wred - type %d\n", NSS_SHAPER_NODE_TYPE_WRED);
 	nss_wred_reset(sch);
 
-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_WRED, 0, qopt->accel_mode) < 0)
+	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_WRED, 0, qopt->accel_mode, extack) < 0)
+	{
 		return -EINVAL;
+	}
 
 	nss_qdisc_info("NSS wred initialized - handle %x parent %x\n", sch->handle, sch->parent);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_wred_change(sch, opt) < 0) {
+#else
+	if (nss_wred_change(sch, opt, extack) < 0) {
+#endif
 		nss_qdisc_destroy(nq);
 		return -EINVAL;
 	}
@@ -374,7 +425,7 @@ static int nss_wred_dump(struct Qdisc *s
 	opt.set_default = q->set_default;
 	opt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL || nla_put(skb, TCA_NSSWRED_PARMS, sizeof(opt), &opt)) {
 		goto nla_put_failure;
 	}
@@ -405,7 +456,9 @@ struct Qdisc_ops nss_red_qdisc_ops __rea
 	.enqueue	=	nss_wred_enqueue,
 	.dequeue	=	nss_wred_dequeue,
 	.peek		=	nss_wred_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_wred_drop,
+#endif
 	.init		=	nss_wred_init,
 	.reset		=	nss_wred_reset,
 	.destroy	=	nss_wred_destroy,
@@ -423,7 +476,9 @@ struct Qdisc_ops nss_wred_qdisc_ops __re
 	.enqueue	=	nss_wred_enqueue,
 	.dequeue	=	nss_wred_dequeue,
 	.peek		=	nss_wred_peek,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		=	nss_wred_drop,
+#endif
 	.init		=	nss_wred_init,
 	.reset		=	nss_wred_reset,
 	.destroy	=	nss_wred_destroy,
--- a/nss_qdisc/nss_wrr.c
+++ b/nss_qdisc/nss_wrr.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -42,7 +42,7 @@ static inline struct nss_wrr_class_data
 	struct Qdisc_class_common *clc;
 	clc = qdisc_class_find(&q->clhash, classid);
 	if (clc == NULL) {
-		nss_qdisc_info("Cannot find class with classid %u in qdisc %p hash table %p\n", classid, sch, &q->clhash);
+		nss_qdisc_info("Cannot find class with classid %u in qdisc %px hash table %px\n", classid, sch, &q->clhash);
 		return NULL;
 	}
 	return container_of(clc, struct nss_wrr_class_data, cl_common);
@@ -53,7 +53,7 @@ static void nss_wrr_destroy_class(struct
 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
 	struct nss_if_msg nim;
 
-	nss_qdisc_info("Destroying nss_wrr class %p from qdisc %p\n", cl, sch);
+	nss_qdisc_info("Destroying nss_wrr class %px from qdisc %px\n", cl, sch);
 
 	/*
 	 * Note, this function gets called even for NSSWRR and not just for NSSWRR_GROUP.
@@ -62,8 +62,8 @@ static void nss_wrr_destroy_class(struct
 	 * only for the root qdisc.
 	 */
 	if (cl == &q->root) {
-		nss_qdisc_info("We do not destroy nss_wrr class %p here since this is "
-				"the qdisc %p\n", cl, sch);
+		nss_qdisc_info("We do not destroy nss_wrr class %px here since this is "
+				"the qdisc %px\n", cl, sch);
 		return;
 	}
 
@@ -84,7 +84,7 @@ static void nss_wrr_destroy_class(struct
 	/*
 	 * And now we destroy the child.
 	 */
-	qdisc_destroy(cl->qdisc);
+	 nss_qdisc_put(cl->qdisc);
 
 	/*
 	 * Stop the stats polling timer and free class
@@ -106,9 +106,15 @@ static void nss_wrr_destroy_class(struct
  * nss_wrr_class_params_validate_and_save()
  *	Validates and saves the class configuration parameters.
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wrr_class_params_validate_and_save(struct Qdisc *sch, struct nlattr **tca,
 					uint32_t *quantum)
+#else
+static int nss_wrr_class_params_validate_and_save(struct Qdisc *sch, struct nlattr **tca,
+					uint32_t *quantum, struct netlink_ext_ack *extack)
+#endif
 {
+	struct nlattr *tb[TCA_NSSWRR_MAX + 1];
 	struct nlattr *opt = tca[TCA_OPTIONS];
 	struct tc_nsswrr_class_qopt *qopt;
 	struct net_device *dev = qdisc_dev(sch);
@@ -123,7 +129,11 @@ static int nss_wrr_class_params_validate
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, TCA_NSSWRR_MAX, TCA_NSSWRR_CLASS_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, tb, TCA_NSSWRR_MAX, TCA_NSSWRR_CLASS_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, tb, TCA_NSSWRR_MAX, TCA_NSSWRR_CLASS_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -218,9 +228,16 @@ static int nss_wrr_ppe_change_class(stru
 }
 #endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wrr_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 		  struct nlattr **tca, unsigned long *arg)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_wrr_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
+		  struct nlattr **tca, unsigned long *arg, struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)*arg;
 	struct nss_if_msg nim_config;
@@ -230,7 +247,11 @@ static int nss_wrr_change_class(struct Q
 
 	nss_qdisc_info("Changing nss_wrr class %u\n", classid);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 	if (nss_wrr_class_params_validate_and_save(sch, tca, &quantum) < 0) {
+#else
+	if (nss_wrr_class_params_validate_and_save(sch, tca, &quantum, extack) < 0) {
+#endif
 		nss_qdisc_warning("validation of configuration parameters for wrr class %x failed\n",
 					sch->handle);
 		return -EINVAL;
@@ -266,7 +287,7 @@ static int nss_wrr_change_class(struct Q
 			return -EINVAL;
 		}
 
-		nss_qdisc_info("NSS_wrr class %u allocated %p\n", classid, cl);
+		nss_qdisc_info("NSS_wrr class %u allocated %px\n", classid, cl);
 		cl->cl_common.classid = classid;
 
 		/*
@@ -275,10 +296,10 @@ static int nss_wrr_change_class(struct Q
 		 * reference count should not be 0.
 		 */
 		cl->qdisc = &noop_qdisc;
-		atomic_set(&cl->nq.refcnt, 1);
+		nss_qdisc_atomic_set(&cl->nq);
 		*arg = (unsigned long)cl;
 
-		nss_qdisc_info("Adding classid %u to qdisc %p hash queue %p\n", classid, sch, &q->clhash);
+		nss_qdisc_info("Adding classid %u to qdisc %px hash queue %px\n", classid, sch, &q->clhash);
 
 		/*
 		 * This is where a class gets initialized. Classes do not have a init function
@@ -286,7 +307,8 @@ static int nss_wrr_change_class(struct Q
 		 * here.
 		 */
 		cl->nq.parent = &q->nq;
-		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_WRR_GROUP, classid, accel_mode) < 0) {
+		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_WRR_GROUP, classid, accel_mode, extack) < 0)
+		{
 			nss_qdisc_error("Nss init for class %u failed\n", classid);
 			return -EINVAL;
 		}
@@ -384,7 +406,11 @@ failure:
 	return -EINVAL;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+static int nss_wrr_delete_class(struct Qdisc *sch, unsigned long arg, struct netlink_ext_ack *extack)
+#else
 static int nss_wrr_delete_class(struct Qdisc *sch, unsigned long arg)
+#endif
 {
 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)arg;
@@ -401,7 +427,7 @@ static int nss_wrr_delete_class(struct Q
 	/*
 	 * The message to NSS should be sent to the parent of this class
 	 */
-	nss_qdisc_info("Detaching nss_wrr class: %p\n", cl);
+	nss_qdisc_info("Detaching nss_wrr class: %px\n", cl);
 	nim.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = q->nq.qos_tag;
 	nim.msg.shaper_configure.config.msg.shaper_node_config.snc.wrr_detach.child_qos_tag = cl->nq.qos_tag;
 	if (nss_qdisc_node_detach(&q->nq, &cl->nq, &nim,
@@ -412,17 +438,24 @@ static int nss_wrr_delete_class(struct Q
 	sch_tree_lock(sch);
 	qdisc_reset(cl->qdisc);
 	qdisc_class_hash_remove(&q->clhash, &cl->cl_common);
-	refcnt = atomic_sub_return(1, &cl->nq.refcnt);
+
+	refcnt = nss_qdisc_atomic_sub_return(&cl->nq);
+
 	sch_tree_unlock(sch);
 	if (!refcnt) {
-		nss_qdisc_error("Reference count should not be zero for class %p\n", cl);
+		nss_qdisc_error("Reference count should not be zero for class %px\n", cl);
 	}
 
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wrr_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
 								 struct Qdisc **old)
+#else
+static int nss_wrr_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
+								 struct Qdisc **old, struct netlink_ext_ack *extack)
+#endif
 {
 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)arg;
@@ -430,10 +463,10 @@ static int nss_wrr_graft_class(struct Qd
 	struct nss_if_msg nim_attach;
 	struct nss_qdisc *nq_new = qdisc_priv(new);
 
-	nss_qdisc_info("Grafting class %p\n", sch);
+	nss_qdisc_info("Grafting class %px\n", sch);
 
 	if (cl == &q->root) {
-		nss_qdisc_error("Can't graft root class %p\n", cl);
+		nss_qdisc_error("Can't graft root class %px\n", cl);
 		return -EINVAL;
 	}
 
@@ -448,10 +481,10 @@ static int nss_wrr_graft_class(struct Qd
 	 * Since we initially attached a noop qdisc as child (in Linux),
 	 * we do not perform a detach in the NSS if its a noop qdisc.
 	 */
-	nss_qdisc_info("Grafting old: %p with new: %p\n", *old, new);
+	nss_qdisc_info("Grafting old: %px with new: %px\n", *old, new);
 	if (*old != &noop_qdisc) {
 		struct nss_qdisc *nq_child = qdisc_priv(*old);
-		nss_qdisc_info("Detaching old: %p\n", *old);
+		nss_qdisc_info("Detaching old: %px\n", *old);
 		nim_detach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = cl->nq.qos_tag;
 		if (nss_qdisc_node_detach(&cl->nq, nq_child, &nim_detach,
 				NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_DETACH) < 0) {
@@ -464,7 +497,7 @@ static int nss_wrr_graft_class(struct Qd
 	 * to the NSS.
 	 */
 	if (new != &noop_qdisc) {
-		nss_qdisc_info("Attaching new: %p\n", new);
+		nss_qdisc_info("Attaching new: %px\n", new);
 		nim_attach.msg.shaper_configure.config.msg.shaper_node_config.qos_tag = cl->nq.qos_tag;
 		nim_attach.msg.shaper_configure.config.msg.shaper_node_config.snc.wrr_group_attach.child_qos_tag = nq_new->qos_tag;
 		if (nss_qdisc_node_attach(&cl->nq, nq_new, &nim_attach,
@@ -486,7 +519,7 @@ static int nss_wrr_graft_class(struct Qd
 static struct Qdisc *nss_wrr_leaf_class(struct Qdisc *sch, unsigned long arg)
 {
 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)arg;
-	nss_qdisc_info("nss_wrr class leaf %p\n", cl);
+	nss_qdisc_info("nss_wrr class leaf %px\n", cl);
 
 	/*
 	 * Since all nss_wrr groups are leaf nodes, we can always
@@ -497,18 +530,19 @@ static struct Qdisc *nss_wrr_leaf_class(
 
 static void nss_wrr_qlen_notify(struct Qdisc *sch, unsigned long arg)
 {
-	nss_qdisc_info("nss_wrr qlen notify %p\n", sch);
+	nss_qdisc_info("nss_wrr qlen notify %px\n", sch);
 	/*
 	 * Gets called when qlen of child changes (Useful for deactivating)
 	 * Not useful for us here.
 	 */
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 static unsigned long nss_wrr_get_class(struct Qdisc *sch, u32 classid)
 {
 	struct nss_wrr_class_data *cl = nss_wrr_find_class(classid, sch);
 
-	nss_qdisc_info("Get nss_wrr class %p - class match = %p\n", sch, cl);
+	nss_qdisc_info("Get nss_wrr class %px - class match = %px\n", sch, cl);
 
 	if (cl != NULL) {
 		atomic_add(1, &cl->nq.refcnt);
@@ -520,16 +554,30 @@ static unsigned long nss_wrr_get_class(s
 static void nss_wrr_put_class(struct Qdisc *sch, unsigned long arg)
 {
 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)arg;
-	nss_qdisc_info("nss_wrr put class for %p\n", cl);
+	nss_qdisc_info("nss_wrr put class for %px\n", cl);
 
 	/*
 	 * We are safe to destroy the qdisc if the reference count
 	 * goes down to 0.
 	 */
-	if (atomic_sub_return(1, &cl->nq.refcnt) == 0) {
+	if (nss_qdisc_atomic_sub_return(&cl->nq) == 0) {
 		nss_wrr_destroy_class(sch, cl);
 	}
 }
+#else
+static unsigned long nss_wrr_search_class(struct Qdisc *sch, u32 classid)
+{
+	struct nss_wrr_class_data *cl = nss_wrr_find_class(classid, sch);
+
+	nss_qdisc_info("Get nss_wrr class %px - class match = %px\n", sch, cl);
+
+	if (cl != NULL) {
+		atomic_add(1, &cl->nq.refcnt.refs);
+	}
+
+	return (unsigned long)cl;
+}
+#endif
 
 static int nss_wrr_dump_class(struct Qdisc *sch, unsigned long arg, struct sk_buff *skb,
 		struct tcmsg *tcm)
@@ -538,7 +586,7 @@ static int nss_wrr_dump_class(struct Qdi
 	struct nlattr *opts;
 	struct tc_nsswrr_class_qopt qopt;
 
-	nss_qdisc_info("Dumping class %p of Qdisc %x\n", cl, sch->handle);
+	nss_qdisc_info("Dumping class %px of Qdisc %x\n", cl, sch->handle);
 
 	qopt.quantum = cl->quantum;
 
@@ -550,7 +598,7 @@ static int nss_wrr_dump_class(struct Qdi
 	tcm->tcm_handle = cl->cl_common.classid;
 	tcm->tcm_info = cl->qdisc->handle;
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL || nla_put(skb, TCA_NSSWRR_CLASS_PARMS, sizeof(qopt), &qopt)) {
 		goto nla_put_failure;
 	}
@@ -565,7 +613,7 @@ static int nss_wrr_dump_class_stats(stru
 {
 	struct nss_qdisc *nq = (struct nss_qdisc *)arg;
 
-	if (nss_qdisc_gnet_stats_copy_basic(d, &nq->bstats) < 0 ||
+	if (nss_qdisc_gnet_stats_copy_basic(sch, d, &nq->bstats) < 0 ||
 			nss_qdisc_gnet_stats_copy_queue(d, &nq->qstats) < 0) {
 		return -1;
 	}
@@ -580,7 +628,7 @@ static void nss_wrr_walk(struct Qdisc *s
 	struct nss_wrr_class_data *cl;
 	unsigned int i;
 
-	nss_qdisc_info("In nss_wrr walk %p\n", sch);
+	nss_qdisc_info("In nss_wrr walk %px\n", sch);
 	if (arg->stop)
 		return;
 
@@ -600,14 +648,22 @@ static void nss_wrr_walk(struct Qdisc *s
 	}
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wrr_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
 {
+	struct netlink_ext_ack *extack = NULL;
+#else
+static int nss_wrr_init_qdisc(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+{
+#endif
 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
+	struct nlattr *tb[TCA_NSSWRR_MAX + 1];
 	int err;
 	struct nss_if_msg nim;
 	struct tc_nsswrr_qopt *qopt;
 
-	nss_qdisc_info("Init nss_wrr qdisc %p\n", sch);
+	nss_qdisc_info("Init nss_wrr qdisc %px\n", sch);
 
 	err = qdisc_class_hash_init(&q->clhash);
 	if (err < 0) {
@@ -620,7 +676,11 @@ static int nss_wrr_init_qdisc(struct Qdi
 	qdisc_class_hash_insert(&q->clhash, &q->root.cl_common);
 	qdisc_class_hash_grow(sch, &q->clhash);
 
-	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, TCA_NSSWRR_MAX, TCA_NSSWRR_QDISC_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, tb, TCA_NSSWRR_MAX, TCA_NSSWRR_QDISC_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, tb, TCA_NSSWRR_MAX, TCA_NSSWRR_QDISC_PARMS, extack);
+#endif
 	if (!qopt) {
 		nss_qdisc_warning("Failed to parse input");
 		return -EINVAL;
@@ -629,7 +689,7 @@ static int nss_wrr_init_qdisc(struct Qdi
 	/*
 	 * Initialize the NSSWRR shaper in NSS
 	 */
-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_WRR, 0, qopt->accel_mode) < 0) {
+	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_WRR, 0, qopt->accel_mode, extack) < 0) {
 		nss_qdisc_warning("Failed init nss_wrr qdisc");
 		return -EINVAL;
 	}
@@ -669,8 +729,14 @@ static int nss_wrr_init_qdisc(struct Qdi
 	return 0;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
 static int nss_wrr_change_qdisc(struct Qdisc *sch, struct nlattr *opt)
+#else
+static int nss_wrr_change_qdisc(struct Qdisc *sch, struct nlattr *opt,
+				struct netlink_ext_ack *extack)
+#endif
 {
+	struct nlattr *tb[TCA_NSSWRR_MAX + 1];
 	struct nss_wrr_sched_data *q;
 	struct tc_nsswrr_qopt *qopt;
 
@@ -680,7 +746,11 @@ static int nss_wrr_change_qdisc(struct Q
 		return -EINVAL;
 	}
 
-	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, TCA_NSSWRR_MAX, TCA_NSSWRR_QDISC_PARMS);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0))
+	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, tb, TCA_NSSWRR_MAX, TCA_NSSWRR_QDISC_PARMS);
+#else
+	qopt = nss_qdisc_qopt_get(opt, nss_wrr_policy, tb, TCA_NSSWRR_MAX, TCA_NSSWRR_QDISC_PARMS, extack);
+#endif
 	if (!qopt) {
 		return -EINVAL;
 	}
@@ -695,7 +765,7 @@ static int nss_wrr_change_qdisc(struct Q
 static void nss_wrr_reset_class(struct nss_wrr_class_data *cl)
 {
 	nss_qdisc_reset(cl->qdisc);
-	nss_qdisc_info("Nsswrr class resetted %p\n", cl->qdisc);
+	nss_qdisc_info("Nsswrr class resetted %px\n", cl->qdisc);
 }
 
 static void nss_wrr_reset_qdisc(struct Qdisc *sch)
@@ -711,7 +781,7 @@ static void nss_wrr_reset_qdisc(struct Q
 	}
 
 	nss_qdisc_reset(sch);
-	nss_qdisc_info("Nsswrr qdisc resetted %p\n", sch);
+	nss_qdisc_info("Nsswrr qdisc resetted %px\n", sch);
 }
 
 static void nss_wrr_destroy_qdisc(struct Qdisc *sch)
@@ -734,8 +804,8 @@ static void nss_wrr_destroy_qdisc(struct
 			 * care of by the nss_wrr_destroy() function.
 			 */
 			if (cl == &q->root) {
-				nss_qdisc_info("We do not detach or destroy nss_wrr class %p here since this is "
-						"the qdisc %p\n", cl, sch);
+				nss_qdisc_info("We do not detach or destroy nss_wrr class %px here since this is "
+						"the qdisc %px\n", cl, sch);
 				continue;
 			}
 
@@ -743,7 +813,7 @@ static void nss_wrr_destroy_qdisc(struct
 			 * Reduce refcnt by 1 before destroying. This is to
 			 * ensure that polling of stat stops properly.
 			 */
-			atomic_sub(1, &cl->nq.refcnt);
+			 nss_qdisc_atomic_sub(&cl->nq);
 
 			/*
 			 * Detach class before destroying it. We dont check for noop qdisc here
@@ -776,7 +846,7 @@ static void nss_wrr_destroy_qdisc(struct
 	 *	 will be taken care of by the graft call.
 	 */
 	nss_qdisc_destroy(&q->nq);
-	nss_qdisc_info("Nsswrr destroyed %p\n", sch);
+	nss_qdisc_info("Nsswrr destroyed %px\n", sch);
 }
 
 static int nss_wrr_dump_qdisc(struct Qdisc *sch, struct sk_buff *skb)
@@ -794,7 +864,7 @@ static int nss_wrr_dump_qdisc(struct Qdi
 
 	opt.accel_mode = nss_qdisc_accel_mode_get(&q->nq);
 
-	opts = nla_nest_start(skb, TCA_OPTIONS);
+	opts = nss_qdisc_nla_nest_start(skb, TCA_OPTIONS);
 	if (opts == NULL) {
 		goto nla_put_failure;
 	}
@@ -809,9 +879,18 @@ nla_put_failure:
 	return -EMSGSIZE;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static int nss_wrr_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+#else
+static int nss_wrr_enqueue(struct sk_buff *skb, struct Qdisc *sch,
+				struct sk_buff **to_free)
+#endif
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	return nss_qdisc_enqueue(skb, sch);
+#else
+	return nss_qdisc_enqueue(skb, sch, to_free);
+#endif
 }
 
 static struct sk_buff *nss_wrr_dequeue(struct Qdisc *sch)
@@ -819,11 +898,13 @@ static struct sk_buff *nss_wrr_dequeue(s
 	return nss_qdisc_dequeue(sch);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 static unsigned int nss_wrr_drop(struct Qdisc *sch)
 {
 	nss_qdisc_info("Nsswrr drop\n");
 	return nss_qdisc_drop(sch);
 }
+#endif
 
 const struct Qdisc_class_ops nss_wrr_class_ops = {
 	.change		= nss_wrr_change_class,
@@ -831,9 +912,17 @@ const struct Qdisc_class_ops nss_wrr_cla
 	.graft		= nss_wrr_graft_class,
 	.leaf		= nss_wrr_leaf_class,
 	.qlen_notify	= nss_wrr_qlen_notify,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	.get		= nss_wrr_get_class,
 	.put		= nss_wrr_put_class,
+#else
+	.find       = nss_wrr_search_class,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	.tcf_chain	= nss_qdisc_tcf_chain,
+#else
+	.tcf_block	= nss_qdisc_tcf_block,
+#endif
 	.bind_tcf	= nss_qdisc_tcf_bind,
 	.unbind_tcf	= nss_qdisc_tcf_unbind,
 	.dump		= nss_wrr_dump_class,
@@ -851,7 +940,9 @@ struct Qdisc_ops nss_wrr_qdisc_ops __rea
 	.enqueue	= nss_wrr_enqueue,
 	.dequeue	= nss_wrr_dequeue,
 	.peek		= qdisc_peek_dequeued,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		= nss_wrr_drop,
+#endif
 	.cl_ops		= &nss_wrr_class_ops,
 	.priv_size	= sizeof(struct nss_wrr_sched_data),
 	.owner		= THIS_MODULE
@@ -863,9 +954,17 @@ const struct Qdisc_class_ops nss_wfq_cla
 	.graft		= nss_wrr_graft_class,
 	.leaf		= nss_wrr_leaf_class,
 	.qlen_notify	= nss_wrr_qlen_notify,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0))
 	.get		= nss_wrr_get_class,
 	.put		= nss_wrr_put_class,
+#else
+	.find       = nss_wrr_search_class,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 	.tcf_chain	= nss_qdisc_tcf_chain,
+#else
+	.tcf_block	= nss_qdisc_tcf_block,
+#endif
 	.bind_tcf	= nss_qdisc_tcf_bind,
 	.unbind_tcf	= nss_qdisc_tcf_unbind,
 	.dump		= nss_wrr_dump_class,
@@ -883,9 +982,10 @@ struct Qdisc_ops nss_wfq_qdisc_ops __rea
 	.enqueue	= nss_wrr_enqueue,
 	.dequeue	= nss_wrr_dequeue,
 	.peek		= qdisc_peek_dequeued,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
 	.drop		= nss_wrr_drop,
+#endif
 	.cl_ops		= &nss_wrr_class_ops,
 	.priv_size	= sizeof(struct nss_wrr_sched_data),
 	.owner		= THIS_MODULE
 };
-
